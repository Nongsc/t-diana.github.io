<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>上善若水</title>
  
  <subtitle>一点一点做好，望吾热爱生活。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.nscblog.top/"/>
  <updated>2020-09-07T07:08:04.783Z</updated>
  <id>https://www.nscblog.top/</id>
  
  <author>
    <name>侬仕超</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序开发-基础篇</title>
    <link href="https://www.nscblog.top/posts/d2a29eb/"/>
    <id>https://www.nscblog.top/posts/d2a29eb/</id>
    <published>2020-08-25T11:20:52.000Z</published>
    <updated>2020-09-07T07:08:04.783Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-yiOJWYdG" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="187672" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><p>想知道微信小程序时怎么玩的，所以开始记录学习过程，不记录的话，感觉很快就忘掉。</p><p>但愿达到可以熟练开发的程序，慢慢坚持。</p><a id="more"></a><h2 id="项目目录讲解"><a href="#项目目录讲解" class="headerlink" title="项目目录讲解"></a>项目目录讲解</h2><ul><li>app.json ：小程序的入口文件，也是小程序的公共配置</li><li>app.js：小程序全局逻辑管理设置</li><li>app.wxss：小程序的公共样式表，不一定需要</li><li>pages文件夹：小程序页面管理，每个页面以文件夹形式存在，文件夹内包含各自的逻辑（js），样式表（wxss），配置表（json），页面结构(wxml)</li></ul><blockquote><p>注意：</p><ol><li>app.json配置页面路径时，只能用绝对路径，不能用相对路径。</li><li>json文件中不允许存在注释</li><li>根据错误信息调错，console内的错误信息基本是语法错误</li></ol></blockquote><h2 id="页面结构基础组件-view-text-image"><a href="#页面结构基础组件-view-text-image" class="headerlink" title="页面结构基础组件(view,text,image)"></a>页面结构基础组件(view,text,image)</h2><p>view组件相当于HTML中的div容器元素</p><p>text和image和HTML中的标签相似</p><h2 id="基本快速布局设置"><a href="#基本快速布局设置" class="headerlink" title="基本快速布局设置"></a>基本快速布局设置</h2><p>使用快速弹性布局设置，设置纵向平均分布时，需要设置相应的高度，设置横向分布时参考纵向分布。</p><h2 id="响应式长度单位rpx"><a href="#响应式长度单位rpx" class="headerlink" title="响应式长度单位rpx"></a>响应式长度单位rpx</h2><p>用于适应不同屏幕的尺寸</p><h2 id="使用navigator组件"><a href="#使用navigator组件" class="headerlink" title="使用navigator组件"></a>使用navigator组件</h2><blockquote><p>作用：链接跳转</p></blockquote><p>基本属性：</p><ul><li>open-type:指定跳转方式，重定向和传统方式，主要体现在左上角的标志<ul><li>标志为房屋，说明是从定向，不能放上一页，直接放回主页</li><li>标志为左箭头，是传统方式跳转，可以放回上一页，不能直接返回主页</li></ul></li><li>hover-class和其他样式指向同一个属性时，哪个样式在后面，后面的样式就会覆盖前一个相应的样式。</li></ul><p>about.wxml中的代码：</p><pre><code class="xml">&lt;navigator url=&quot;/pages/weekly/weekly&quot; open-type=&quot;switchTab&quot; hover-class=&quot;click-class&quot; class=&quot;re&quot;&gt;每周推荐&lt;/navigator&gt;</code></pre><h2 id="全局配置——tabBar"><a href="#全局配置——tabBar" class="headerlink" title="全局配置——tabBar"></a>全局配置——tabBar</h2><blockquote><p>作用：用于标签页的切换</p></blockquote><p>使用时，navigator的open-type使用默认属性值时，navigator将会失效</p><p>app.json中的代码</p><pre><code class="json">&quot;tabBar&quot;: {    &quot;list&quot;: [      {        &quot;text&quot;: &quot;每周推荐&quot;,        &quot;pagePath&quot;: &quot;pages/weekly/weekly&quot;      },      {        &quot;text&quot;: &quot;关于&quot;,        &quot;pagePath&quot;: &quot;pages/about/about&quot;      }    ],    &quot;color&quot;: &quot;#000000&quot;,    &quot;selectedColor&quot;: &quot;#ffffff&quot;,    &quot;backgroundColor&quot;: &quot;#BEBEBE&quot;  }</code></pre><h2 id="全局配置——window"><a href="#全局配置——window" class="headerlink" title="全局配置——window"></a>全局配置——window</h2><blockquote><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p></blockquote><p>自行上机看效果</p><pre><code class="json">&quot;window&quot;: {    &quot;navigationBarBackgroundColor&quot;: &quot;#BEBEBE&quot;, #导航栏背景色    &quot;navigationBarTextStyle&quot;: &quot;white&quot;,#导航栏文字颜色，属性值只有white | black    &quot;navigationBarTitleText&quot;: &quot;电影周周看&quot; #导航栏标题文字  }</code></pre><h2 id="数据绑定——从视图中抽离出数据"><a href="#数据绑定——从视图中抽离出数据" class="headerlink" title="数据绑定——从视图中抽离出数据"></a>数据绑定——从视图中抽离出数据</h2><blockquote><p>WXML 中的动态数据均来自对应 Page 的 data。</p></blockquote><p>如同在配置文件中动态的给相应的数据</p><p>页面结构：</p><pre><code class="xml">&lt;view class=&quot;container&quot;&gt;  &lt;text&gt;本周推荐&lt;/text&gt;  &lt;image class=&quot;weekly-banner&quot; src=&quot;{{thisWeekMovie.imageSrc}}&quot;&gt;&lt;/image&gt;  &lt;text&gt;{{thisWeekMovie.name}}&lt;/text&gt;  &lt;text&gt;{{thisWeekMovie.comment}}&lt;/text&gt;&lt;/view&gt;</code></pre><p>js中文件数据：</p><pre><code class="javascript">Page({  data:{    thisWeekMovie:{      name:&quot;教父&quot;,      imageSrc:&quot;/images/timg.png&quot;,      comment:&quot;点评：最精彩的剧本，最真实的黑帮社会。&quot;    }  }})</code></pre><blockquote><p>注意：</p><p>可以同过开发者工具调试器的APPdata，实时调试每个页面的所有内部状态变量的取值。</p></blockquote><h2 id="小程序运行环境与基本架构"><a href="#小程序运行环境与基本架构" class="headerlink" title="小程序运行环境与基本架构"></a>小程序运行环境与基本架构</h2><p>观看<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#%E6%B8%B2%E6%9F%93%E5%B1%82%E5%92%8C%E9%80%BB%E8%BE%91%E5%B1%82" target="_blank" rel="noopener">官方文档</a></p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><strong>wx:if</strong></p><p>在框架中，使用 <code>wx:if=&quot;&quot;</code> 来判断是否需要渲染该代码块：</p><p>与hidden的区别，默认为true时，你想要的结构要为false才展示。不管怎么样，hidden都要先渲染，内存开销比较大。</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><blockquote><p>重复的渲染生成组件</p></blockquote><p>通过wx:for实现</p><p>页面结构</p><pre><code class="xml">&lt;view class=&quot;movie&quot; wx:for=&quot;{{weeklyMovieList}}&quot;&gt;    &lt;image class=&quot;weekly-banner&quot; src=&quot;{{item.imageSrc}}&quot;&gt;&lt;/image&gt;    &lt;view class=&quot;movie-detail&quot;&gt;      &lt;text&gt;{{item.name}}&lt;/text&gt;      &lt;text&gt;{{item.comment}}&lt;/text&gt;      &lt;text wx:if=&quot;{{item.isRecommded}}&quot; style=&quot;color:red; font-weight:bold;&quot;&gt;强烈推荐&lt;/text&gt;    &lt;/view&gt;</code></pre><p>逻辑代码</p><pre><code class="javascript">Page({  data:{    weeklyMovieList:    [      {        name:&quot;教父&quot;,        imageSrc:&quot;/images/timg.png&quot;,        comment:&quot;点评：最精彩的剧本，最真实的黑帮社会。&quot;,        isRecommded:true      },      {        name:&quot;教父&quot;,        imageSrc:&quot;/images/timg.png&quot;,        comment:&quot;点评：最精彩的剧本，最真实的黑帮社会。&quot;,        isRecommded:false      },      {        name:&quot;教父&quot;,        imageSrc:&quot;/images/timg.png&quot;,        comment:&quot;点评：最精彩的剧本，最真实的黑帮社会。&quot;,        isRecommded:false      },      {        name:&quot;教父&quot;,        imageSrc:&quot;/images/timg.png&quot;,        comment:&quot;点评：最精彩的剧本，最真实的黑帮社会。&quot;,        isRecommded:false      },      {        name:&quot;教父&quot;,        imageSrc:&quot;/images/timg.png&quot;,        comment:&quot;点评：最精彩的剧本，最真实的黑帮社会。&quot;,        isRecommded:false      }    ]  }})</code></pre><h2 id="swiper视图容器组件"><a href="#swiper视图容器组件" class="headerlink" title="swiper视图容器组件"></a>swiper视图容器组件</h2><blockquote><p>滑块视图容器。其中只可放置<a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html" target="_blank" rel="noopener">swiper-item</a>组件，否则会导致未定义的行为。</p></blockquote><p>页面结构代码(weekly.wxml)</p><pre><code class="xml">&lt;swiper class=&quot;movie-swiper&quot; indicator-dots=&quot;{{true}}&quot;&gt;    &lt;swiper-item class=&quot;movie&quot; wx:for=&quot;{{weeklyMovieList}}&quot;&gt;      &lt;view class=&quot;container movie-detail&quot;&gt;        &lt;image class=&quot;weekly-banner&quot; src=&quot;{{item.imageSrc}}&quot;&gt;&lt;/image&gt;        &lt;text&gt;{{item.name}}&lt;/text&gt;        &lt;text&gt;{{item.comment}}&lt;/text&gt;        &lt;text wx:if=&quot;{{item.isRecommded}}&quot; style=&quot;color:red; font-weight:bold;&quot;&gt;强烈推荐&lt;/text&gt;      &lt;/view&gt;    &lt;/swiper-item&gt;  &lt;/swiper&gt;</code></pre><h2 id="页面的生命周期函数"><a href="#页面的生命周期函数" class="headerlink" title="页面的生命周期函数"></a>页面的生命周期函数</h2><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" alt="小程序页面路径" loading="lazy"></p><p>图片来自<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html" target="_blank" rel="noopener">官方文档</a></p><p>页面生命周期：</p><ol><li>onLoad：首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。</li><li>onShow：重新进入页面时触发。</li><li>onReady：页面首次渲染完成时触发。</li><li>onHide：从前台切到后台或进入其他页面触发。</li><li>onUnload：页面卸载时触发。</li></ol><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><blockquote><p>在小程序中对内部状态数据进行更新，不能采用直接赋值方式写入。</p><p>小程序中视图层内部变量的数据变化，不会对逻辑层内部变量数据产生影响。说明逻辑层对视图层数据绑定为单向数据绑定，不是双向绑定。</p></blockquote><p>this.setData()：</p><ol><li>更新数据需要通过其函数进行调用。</li><li>当data中没有内部变量时，会往data中添加一个内部变量，然后进行赋值。</li><li>可以对局部数据进行更新。</li></ol><pre><code class="javascript">onShow:function (event) {    this.setData({      &quot;weeklyMovieList[0].name&quot;:&quot;yellow3&quot;, /*局部变量更新*/    })  }</code></pre><h2 id="事件机制-响应用户交互"><a href="#事件机制-响应用户交互" class="headerlink" title="事件机制-响应用户交互"></a>事件机制-响应用户交互</h2><p>冒泡事件：子类事件会触发父类的事件。</p><p>非冒泡事件：子类事件不会触发父类的事件。</p><p>bindtap和catchtap属性之间的区别：</p><blockquote><p>除 <code>bind</code> 外，也可以用 <code>catch</code> 来绑定事件。与 <code>bind</code> 不同， <code>catch</code> 会阻止事件向上冒泡。</p></blockquote><p>事件编程：</p><p>​     js中的事件要素</p><p>​     1、事件源：通常指发生事件的标签 HTML</p><p>​     2、事件属性：发生事件的性质  单击 双击 鼠标移入…</p><p>​     3、事件监听：发生事件后执行的功能 函数</p><p>结构代码:</p><pre><code class="xml">&lt;text class=&quot;return-thisWeek&quot; catchtap=&quot;returnButton&quot; wx:if=&quot;{{index<currentIndex}}&quot;&gt;返回本周&lt;/text&gt;&lt;!--catcah：是不会触发冒泡事件--&gt;</code></pre><p>逻辑代码：</p><pre><code class="javascript">returnButton:function (event) {    this.setData({        /*        对当前页进行更新        */      currentIndex:this.data.weeklyMovieList.length-1    })  }</code></pre><h2 id="组件的自定义属性"><a href="#组件的自定义属性" class="headerlink" title="组件的自定义属性"></a>组件的自定义属性</h2><blockquote><p>作用：想逻辑层传递业务数据</p></blockquote><p>页面结构代码：</p><pre><code class="xml">&lt;view class=&quot;container movie-detail&quot; bindtap=&quot;toDetail&quot; data-movieId=&quot;{{item.id}}&quot;&gt;</code></pre><p>逻辑层代码：</p><pre><code class="javascript">toDetail:function(event){    var movieId=event.currentTarget.dataset.movieid;    console.log(event.currentTarget);    wx.navigateTo({      url: &#39;/pages/detail/detail?id=&#39;+movieId,    })  }</code></pre><p>组件自定义属性：</p><ul><li>以<code>data-属性名</code> 命名,如页面结构代码中的data-movieId</li><li>在逻辑层中通过<code>event.currentTarget.dataset.属性名</code>来获取属性名对应的属性值，注意组件自定义属性默认全小写，除非两个单词之间用<code>-</code>分隔，如：data-movie-id;</li></ul><p>这次写的练习项目因为涉及到了页面跳转，在<a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html" target="_blank" rel="noopener">官方文档</a>中称为路由</p><h2 id="发起请求API"><a href="#发起请求API" class="headerlink" title="发起请求API"></a>发起请求API</h2><p>类似于Ajax的使用，异步请求</p><pre><code class="javascript">onLoad:function(options){    // console.log(options)    wx.request({//与Ajax相同的异步请求      url: &#39;url&#39;,//请求地址 这个地址必须在后台存在，域名必须是经过备案的      data:{},//请求参数      method:&#39;GET&#39;,//请求方式      header:{        //请求数据MIMA格式，比如默认的：aplication/json      },      success:function(res){//成功时执行的回调函数          //this.setdata();//这样是不合理的，this这时指向的是success      },      fail:function(){},//失败时执行的回调函数      complete:function(){},//完成时执行的回调函数    })  }</code></pre><h2 id="动态设置导航栏loading状态"><a href="#动态设置导航栏loading状态" class="headerlink" title="动态设置导航栏loading状态"></a>动态设置导航栏loading状态</h2><blockquote><p>作用：在当前页面显示导航条加载动画</p></blockquote><p>个人觉得只是给用户心里安慰，用于缓解网络延迟带来的影响</p><pre><code class="JavaScript">wx.showNavigationBarLoading(Object object){//展示加载动画    success:function(){        //加载成功    },    fail:function(){        //加载失败    },    complete:function(){        //加载完成后执行的回调函数，不管失败还是成功，都会执行    }}wx.hideNavigationBarLoading(){//隐藏加载动画    success: (res) =&gt; {        console.log(&quot;加载完成&quot;)    }}</code></pre><h2 id="页面处理函数与自定义页面转发"><a href="#页面处理函数与自定义页面转发" class="headerlink" title="页面处理函数与自定义页面转发"></a>页面处理函数与自定义页面转发</h2><p>详情见<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html" target="_blank" rel="noopener">官方文档</a></p><p>自己上机敲打，调试</p><pre><code class="javascript">//首先打开页面分享//我选择在页面加载完成后就打开页面分享  onLoad: function (options) {    wx.showShareMenu({      withShareTicket: true,      menus: [&#39;shareAppMessage&#39;, &#39;shareTimeline&#39;]    })  }//自定义页面转发相关的信息，如标题，路径onShareAppMessage:function(res){    console.log(res)    if(res.from!=&#39;button&#39;){//判断触发分享事件的是不是按钮      console.log(&quot;this isn&#39;t button&quot;)    }    return{      title:&quot;emmmm&quot;,      path:&quot;/images/timg.png&quot;,    }  }</code></pre><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><blockquote><p>这里的组件不仅仅是指页面结构组件，这里的组件是以某种方式对业务逻辑和功能进行封装</p></blockquote><h3 id="定义一个组件"><a href="#定义一个组件" class="headerlink" title="定义一个组件"></a>定义一个组件</h3><h4 id="组件的特点"><a href="#组件的特点" class="headerlink" title="组件的特点"></a>组件的特点</h4><ul><li>高内聚</li><li>可复用</li></ul><p>通过<strong>配置</strong>和<strong>事件</strong>的方式来实现组件的定义，而组件是由wxml、wxss、js、json构成。</p><h3 id="小程序中的组件"><a href="#小程序中的组件" class="headerlink" title="小程序中的组件"></a>小程序中的组件</h3><p>详情见<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">官方文档</a></p><h3 id="Component构造器"><a href="#Component构造器" class="headerlink" title="Component构造器"></a>Component构造器</h3><blockquote><p><code>Component</code> 构造器可用于定义组件，调用 <code>Component</code> 构造器时可以指定组件的属性、数据、方法等。</p></blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html" target="_blank" rel="noopener">官方文档</a>的详细介绍</p><p>我们主要关注的是</p><ol><li><p>组件的数据维护</p><table><thead><tr><th align="left">定义段</th><th align="left">类型</th><th align="left">是否必填</th><th align="left">描述</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">properties</td><td align="left">Object Map</td><td align="left">否</td><td align="left">组件的对外属性，是属性名到属性设置的映射表</td><td align="left"></td></tr><tr><td align="left">data</td><td align="left">Object</td><td align="left">否</td><td align="left">组件的内部数据，和 <code>properties</code> 一同用于组件的模板渲染</td><td align="left"></td></tr></tbody></table></li><li><p>组件的方法</p><table><thead><tr><th>定义段</th><th>类型</th><th>是否必填</th><th>描述</th></tr></thead><tbody><tr><td>methods</td><td>object</td><td>组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html" target="_blank" rel="noopener">组件间通信与事件</a></td><td></td></tr></tbody></table></li><li><p>组件的生命周期</p><table><thead><tr><th>定义段</th><th>类型</th><th>是否必填</th><th>描述</th><th></th></tr></thead><tbody><tr><td>created</td><td>Function</td><td>否</td><td>组件生命周期函数-在组件实例刚刚被创建时执行，注意此时不能调用 <code>setData</code> )</td><td></td></tr><tr><td>attached</td><td>Function</td><td>否</td><td>组件生命周期函数-在组件实例进入页面节点树时执行)</td><td></td></tr><tr><td>ready</td><td>Function</td><td>否</td><td>组件生命周期函数-在组件布局完成后执行)</td><td></td></tr><tr><td>moved</td><td>Function</td><td>否</td><td>组件生命周期函数-在组件实例被移动到节点树另一个位置时执行)</td><td></td></tr><tr><td>detached</td><td>Function</td><td>否</td><td>组件生命周期函数-在组件实例被从页面节点树移除时执行)</td><td></td></tr></tbody></table></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-yiOJWYdG&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;187672&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;p&gt;想知道微信小程序时怎么玩的，所以开始记录学习过程，不记录的话，感觉很快就忘掉。&lt;/p&gt;
&lt;p&gt;但愿达到可以熟练开发的程序，慢慢坚持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序开发学习记录" scheme="https://www.nscblog.top/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="微信小程序" scheme="https://www.nscblog.top/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="JavaScript" scheme="https://www.nscblog.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java集合复习记录</title>
    <link href="https://www.nscblog.top/posts/45f2326c/"/>
    <id>https://www.nscblog.top/posts/45f2326c/</id>
    <published>2020-08-23T03:31:08.000Z</published>
    <updated>2020-08-25T07:05:30.320Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-VHZiDiiE" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="479764527" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><p>Java容器复习，挺重要的，好好复习。</p><p>不敲笔记，感觉都会忘完。</p><a id="more"></a><h2 id="2020-08-24-第一天Java集合复习记录"><a href="#2020-08-24-第一天Java集合复习记录" class="headerlink" title="2020-08-24-第一天Java集合复习记录"></a>2020-08-24-第一天Java集合复习记录</h2><h3 id="List-Set-Map之间的区别"><a href="#List-Set-Map之间的区别" class="headerlink" title="List,Set,Map之间的区别"></a>List,Set,Map之间的区别</h3><ul><li>List:有序，可重复，有下标</li><li>Set:不重复，无下标，无序</li><li>Map:<ul><li>使用键值对存储数据</li><li>key :无序，无下标，不重复,key可以为NULL</li><li>value:可以重复，value可以为NULL</li></ul></li></ul><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><ol><li><p>线程安全：两者都不是同步的，所以线程是不安全的</p></li><li><p>底层数据结构：</p><ol><li>ArrayList底层使用的Object数组</li><li>LinkedList底层使用的是双向链表</li></ol></li><li><p>插入和删除元素</p><ol><li>ArrayList采用数组存储，写操作慢，读操作快</li><li>LinkedList底层是双向链表，增删快，查询慢</li></ol></li><li><p>快速随机访问：通过序号快速获取元素</p><ol><li>LinkedList不支持快速随机访问</li><li>ArrayList支持通过下标访问</li></ol></li><li><p>内存空间占用：</p><ol><li>ArrayList的空间浪费主要体现在结尾会预留一定的容量空间</li><li>LinkedList的空间花费体现在每个元素都要消耗比ArrayList更多的空间</li></ol></li><li><blockquote><p>RandomAccess是快速访问的标识，因为ArrayList天然支持快速随机访问，ArrayList实现了RandomAccess接口，ArrayList就具有快速随机访问功能</p></blockquote></li></ol><h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>默认初始容量为：</p><pre><code class="Java">/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;</code></pre><p>无参构造初始是一个空的数组：</p><pre><code class="Java">/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() {    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}</code></pre><p>设置初始容量的有参构造：</p><pre><code class="Java">public ArrayList(int initialCapacity) {    if (initialCapacity &gt; 0) {//正确容量的话，给一个大小为容量的Object数组        this.elementData = new Object[initialCapacity];    } else if (initialCapacity == 0) {//当容量为0，设置空数组        this.elementData = EMPTY_ELEMENTDATA;    } else {//否则就抛出异常        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-VHZiDiiE&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;479764527&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;p&gt;Java容器复习，挺重要的，好好复习。&lt;/p&gt;
&lt;p&gt;不敲笔记，感觉都会忘完。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试准备记录" scheme="https://www.nscblog.top/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java" scheme="https://www.nscblog.top/tags/Java/"/>
    
      <category term="Java集合" scheme="https://www.nscblog.top/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java基础复习记录</title>
    <link href="https://www.nscblog.top/posts/318fc0d1/"/>
    <id>https://www.nscblog.top/posts/318fc0d1/</id>
    <published>2020-08-13T14:54:30.000Z</published>
    <updated>2020-08-23T06:05:33.552Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-AzerXupq" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5253801" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><p>去年7月份在培训机构中培训了半年，本想以为能找个待遇不错的工作。</p><p>因为学的不够精进，无缘Java开发工程师这个职位。</p><p>我内心还想着从事关于计算机编程的职业，我喜欢计算机编程，但还不够热爱。</p><p>所以现在复习，强化自己的基础。能让自己有相应的硬实力。</p><blockquote><p>首先声明，这个看JavaGuide的复习记录，因而摘抄了大部分内容，用于加深理解和记忆。这个不算是原创。</p></blockquote><a id="more"></a><h2 id="2020-08-12-第六天Java基础复习"><a href="#2020-08-12-第六天Java基础复习" class="headerlink" title="2020-08-12-第六天Java基础复习"></a>2020-08-12-第六天Java基础复习</h2><h3 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><blockquote><p><strong>发生在同一个类中</strong>，方法名相同，参数列表不同(参数个数，类型，顺序)，与返回值，访问修饰符无关。</p></blockquote><p><strong>注意：Java允许重载任何方法。</strong></p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><blockquote><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写。重写需要两个类。</p></blockquote><p>重写的要求：</p><ol><li>方法名相同，参数列表相同。</li><li>返回值返回小于父类。</li><li>抛出的异常小于父类。</li><li>访问修饰符大于等于父类。</li></ol><h3 id="Java面向对象的三大特性"><a href="#Java面向对象的三大特性" class="headerlink" title="Java面向对象的三大特性"></a>Java面向对象的三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote><p>对属性进行私有化，提供相应的get/set方法。规范对属性的操作。</p></blockquote><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote><p>通过关键字extends实现，如果要继承，必须满足is a关系。比如：我是个人。</p></blockquote><p>注意：</p><ol><li>子类拥有父类对象所有的属性和方法，但是父类中的私有属性和方法子类是无法访问的。</li><li>子类可以拥有自己的属性和方法，也就是子类可以对父类进行扩展。</li><li>子类可以用自己的方法实现父类的方法。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><blockquote><p>程序中定义的引用变量所指向具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行时期间才确定。</p></blockquote><hr><h2 id="2020-08-13-第七天Java基础复习"><a href="#2020-08-13-第七天Java基础复习" class="headerlink" title="2020-08-13-第七天Java基础复习"></a>2020-08-13-第七天Java基础复习</h2><h3 id="String、StringBuffer和StringBuilder之间的区别。String为什么是不可变的？"><a href="#String、StringBuffer和StringBuilder之间的区别。String为什么是不可变的？" class="headerlink" title="String、StringBuffer和StringBuilder之间的区别。String为什么是不可变的？"></a>String、StringBuffer和StringBuilder之间的区别。String为什么是不可变的？</h3><ul><li><p>可变性</p><p>String类中使用final关键字修饰字符数组来保存字符串。所以String对象是不可变的</p><p>StringBuffer和StringBuilder继承AbstractStringBuilder类，在这个类中字符数组并没有使用final修饰，所以这两种对象是可变的</p></li><li><p>线程安全性</p><p>String不可变，线程安全</p><p>StringBuffer对方法加了些同步锁或者对调用的方法加了同步锁，所以线程安全。</p><p>StringBuilder并没有对方法进行同步加锁，线程不安全。</p></li><li><p>性能</p><p>StringBuffer线程安全，效率低</p><p>StirngBuilder线程不安全，效率高。</p></li></ul><h3 id="在静态方法内调用一个非静态成员为什么是非法的？"><a href="#在静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在静态方法内调用一个非静态成员为什么是非法的？"></a>在静态方法内调用一个非静态成员为什么是非法的？</h3><p>static与类有关，与对象无关，非静态成员是与对象相关联的。当通过类名调用静态方法时，并没有创建对象，从而不能调用非静态成员。</p><h3 id="在Java中定义一个无参构造的作用"><a href="#在Java中定义一个无参构造的作用" class="headerlink" title="在Java中定义一个无参构造的作用"></a>在Java中定义一个无参构造的作用</h3><p>在创建子类对象前，会先用super(),也就是先创建父类对象，如果父类之定义有参构造，而没有无参构造的话，super()就无法匹配，编译报错。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><table><thead><tr><th></th><th>interface</th><th>abstract class</th></tr></thead><tbody><tr><td>变量</td><td>公开静态最终常量</td><td>没有限制</td></tr><tr><td>方法</td><td>公开抽象方法，不能有实现(Java8后可以有默认实现)</td><td>可以存在非抽象方法</td></tr><tr><td>访问修饰符</td><td>默认public</td><td>抽象方法是为了被重写所以不能使用private修饰</td></tr><tr><td>设计层面</td><td>接口是对行为的抽象，是一种行为规范。</td><td>抽象是对类的抽象，是一种模板设计。</td></tr></tbody></table><h3 id="创建对象用什么运算符？对象实体与对象引用有何不同？"><a href="#创建对象用什么运算符？对象实体与对象引用有何不同？" class="headerlink" title="创建对象用什么运算符？对象实体与对象引用有何不同？"></a>创建对象用什么运算符？对象实体与对象引用有何不同？</h3><p>new运算符</p><p>new创建对象实例在堆内存中；对象引用指向对象实例在栈内存中。</p><p>一个对象引用可以指向0或1个对象</p><p>一个对象可以有n引用指向</p><h3 id="什么是返回值，返回值的作用"><a href="#什么是返回值，返回值的作用" class="headerlink" title="什么是返回值，返回值的作用"></a>什么是返回值，返回值的作用</h3><p>方法运行产生的结果，接收结果，用于其他操作。</p><h3 id="静态方法与实例方法有何不同"><a href="#静态方法与实例方法有何不同" class="headerlink" title="静态方法与实例方法有何不同"></a>静态方法与实例方法有何不同</h3><p>调用方式：</p><p>​    1.静态方法可以通过类名调用也可以通过对象名进行调用</p><p>​    2.实例方法只能通过对象名进行调用。</p><p>访问本类成员：</p><p>​    1.静态方法只能访问静态成员，不允许访问实例成员和实例方法。</p><p>​    2.实例方法没有限制。</p><h3 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h3><blockquote><p>hashCode和equals就是为了去重，先用hashCode确定两个对象的hash值是否相同，然后equals确定是否是同一对象。</p></blockquote><h4 id="hashCode介绍"><a href="#hashCode介绍" class="headerlink" title="hashCode介绍"></a>hashCode介绍</h4><p>hashCode 是获取哈希码，也叫散列码。返回的是一个int整数</p><h4 id="hashCode存在的理由"><a href="#hashCode存在的理由" class="headerlink" title="hashCode存在的理由"></a>hashCode存在的理由</h4><p>用于检查判断两个对象的hashCode是否相同。不同的话散列在其他位置(减少equals的次数)，相同在调用equals比较对象内容是否相同。</p><p>hashCode和equals相关规定</p><ol><li>两个对象相等，则hashCode一定也是相同的</li><li>两个对象相等，对象两个对象分别调用equals方法返回true</li><li>两个对象的hashCode相同，两个对象也不定相等</li><li>equals方法被覆盖过(重写)，则hashCode方法也必须被覆盖(重写)。</li><li>hashCode的默认行为是对堆上的对象产生独特值，如果没有重写hashCode，则该类的两个对象无论如何都不会相等。</li></ol><hr><h2 id="2020-08-14-第八天Java基础复习"><a href="#2020-08-14-第八天Java基础复习" class="headerlink" title="2020-08-14-第八天Java基础复习"></a>2020-08-14-第八天Java基础复习</h2><h3 id="简述线程、程序和进程的基本概念与他们之间的关系"><a href="#简述线程、程序和进程的基本概念与他们之间的关系" class="headerlink" title="简述线程、程序和进程的基本概念与他们之间的关系"></a>简述线程、程序和进程的基本概念与他们之间的关系</h3><p>线程是比进程更小的执行单位(在项目中就如同一个可以执行的功能)。同类的多个线程共享一块内存空间和一组系统资源。所以系统产生一个线程或是在各个线程之间切换工作是，负担比进程小的多，因而线程也被称为轻量级进程。</p><p>程序就是静态的代码。</p><p>进程就是程序的一次执行过程。</p><p>线程和进程的最大不同在于基本上各进程是独立的，各线程不一定，同一进程中的线程可能会互相影响。</p><h2 id="2020-08-19-第九天Java基础复习"><a href="#2020-08-19-第九天Java基础复习" class="headerlink" title="2020-08-19-第九天Java基础复习"></a>2020-08-19-第九天Java基础复习</h2><h3 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态"></a>线程有哪些基本状态</h3><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程被创建，但还没有调用start()方法</td></tr><tr><td>RUANNABLE</td><td>运行状态，线程将操作系统中的就绪和运行两种状态笼统称作“运行中”</td></tr><tr><td>BLOCKED</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态，表示线程进入等待状态，进入该状态需要等待其他线程做出一些特定动作(通知或中断)</td></tr><tr><td>TIME_WAITING</td><td>有限期等待，不同waiting状态，它可以在指定时间内自行返回</td></tr><tr><td>TERMINATED</td><td>终止状态，表示当前线程已经执行完毕。</td></tr></tbody></table><p>线程创建后处于 <strong>NEW(新建)</strong>状态，调用start()开始运行线程这时处于 <strong>READY(可运行)</strong>状态，当线程获得CPU时间片后处于 <strong>RUNNING(运行)</strong>状态。</p><p>当线程调用同步方法时，在没有获取到锁的情况下，线程会进入到 <strong>BLOCKED(阻塞)</strong>状态。</p><p>线程执行Runnable的run方法后进入 <strong>TERMINATED</strong>状态。</p><h3 id="关于final关键字的一些总结"><a href="#关于final关键字的一些总结" class="headerlink" title="关于final关键字的一些总结"></a>关于final关键字的一些总结</h3><ol><li><p>修饰变量</p><ul><li>基本数据类型，数值初始化后不能更改</li><li>引用类型，不能指向其他对象</li></ul></li><li><p>修饰类</p><p>这个类不能被继承。类中的方法都会被隐式声明为final方法</p></li><li><p>修饰方法</p><p>把方法锁定，防止任何类继承继承修改</p></li></ol><h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><h4 id="Throwable类中常用的方法"><a href="#Throwable类中常用的方法" class="headerlink" title="Throwable类中常用的方法"></a>Throwable类中常用的方法</h4><ul><li>public String getMessage():返回异常发生的简要描述</li><li>public String toString():返回异常发生时的详细信息</li><li>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</li></ul><h4 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h4><ul><li><strong>try块</strong>：用于捕获异常，后面跟0-N个catch块，没有catch块，则必须有一个finally块</li><li><strong>catch块</strong>：处理异常</li><li><strong>finally块</strong>：是否捕获异常或是处理异常，finally块都会执行，当try或catch块里有return时，先执行finally语句块将在方法返回之前执行。</li></ul><p><strong>以下finally块不会被执行：</strong></p><ul><li>finally语句块第一行发生了异常</li><li>前面代码用到了System.exit(int)已退出程序。exit是带参函数；若该语句在异常语句之后，finally会执行。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><p><strong>try语句finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。</strong></p><p><strong>既有字节流，为什么还要有字符流？</strong></p><blockquote><p>信息的最小存储单元都是字节。</p><p>字符流是由Java虚拟机将字节码转换得到的，但如果我们不知道编码类型，容易出现乱码问题，并且Java虚拟机转换过程比较耗时，所以I/O流直接提供了操作字符的接口。</p></blockquote><h2 id="2020-08-20-第十天Java基础复习"><a href="#2020-08-20-第十天Java基础复习" class="headerlink" title="2020-08-20-第十天Java基础复习"></a>2020-08-20-第十天Java基础复习</h2><h3 id="BIO-NIO-AIO之间的区别"><a href="#BIO-NIO-AIO之间的区别" class="headerlink" title="BIO,NIO,AIO之间的区别"></a>BIO,NIO,AIO之间的区别</h3><ul><li>BIO：同步阻塞I/O，数据的读写必须阻塞在一个线程内等待其完成。适用于连接数不是特别高的情况下</li><li>NIO：同步非阻塞I/O，支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的Socket和ServerScoket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。</li><li>AIO：AIO就是NIO2，Java7引入NIO的改进版，是异步非阻塞IO模型。异步IO基于事件和回调机制实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-AzerXupq&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;5253801&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;p&gt;去年7月份在培训机构中培训了半年，本想以为能找个待遇不错的工作。&lt;/p&gt;
&lt;p&gt;因为学的不够精进，无缘Java开发工程师这个职位。&lt;/p&gt;
&lt;p&gt;我内心还想着从事关于计算机编程的职业，我喜欢计算机编程，但还不够热爱。&lt;/p&gt;
&lt;p&gt;所以现在复习，强化自己的基础。能让自己有相应的硬实力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先声明，这个看JavaGuide的复习记录，因而摘抄了大部分内容，用于加深理解和记忆。这个不算是原创。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="面试准备记录" scheme="https://www.nscblog.top/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java基础" scheme="https://www.nscblog.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Java" scheme="https://www.nscblog.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对文件的输入输出</title>
    <link href="https://www.nscblog.top/posts/4e1c1c23/"/>
    <id>https://www.nscblog.top/posts/4e1c1c23/</id>
    <published>2020-06-28T16:15:46.000Z</published>
    <updated>2020-08-23T06:11:53.283Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-vJVBbCqk" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="10-1-C文件的有关基本知识"><a href="#10-1-C文件的有关基本知识" class="headerlink" title="10.1    C文件的有关基本知识"></a>10.1    C文件的有关基本知识</h2><h3 id="10-1-1-什么是文件"><a href="#10-1-1-什么是文件" class="headerlink" title="10.1.1    什么是文件"></a>10.1.1    什么是文件</h3><p>程序设计中主要用到两种文件：</p><ol><li>程序文件。源文件，目标文件，可执行文件，文件内容为程序代码</li><li>数据文件。文件内容不是不是程序代码，是程序文件运行时读写的数据。</li></ol><a id="more"></a><p>本章主要讨论<strong>数据文件</strong></p><p>从操作系统角度看，每个与主机相连的输入输出设备看作一个文件。</p><p>文件一般指存储在外部介质上数据的集合。</p><p>输入输出是数据传送的过程。输入输出也被称为流，也就是数据流。</p><p>C语言把文件看做是一个字符（或字节）的序列。</p><p>一个输入输出流就是一个字符或字节(内容为进制数据)流。</p><p>输入输出数据流的开始和结束仅受程序控制而不受物理符号（如回车换行）的控制，这样的文件称为流式文件。</p><h3 id="10-1-2-文件名"><a href="#10-1-2-文件名" class="headerlink" title="10.1.2    文件名"></a>10.1.2    文件名</h3><p>文件要有唯一的文件标识，以便用户识别和引用。</p><p>文件标识包括3各部分：</p><ol><li>文件路径</li><li>文件名主干(包含文件后缀)</li><li>文件后缀：表示文件的<u><strong>性质</strong></u>(图片还是文本)</li></ol><p>文件标识常称为文件名，不仅仅是文件名主干</p><h3 id="10-1-3-文件的分类"><a href="#10-1-3-文件的分类" class="headerlink" title="10.1.3    文件的分类"></a>10.1.3    文件的分类</h3><p>数据的组织形式，数据文件分为<strong>ASCII文件</strong>和<strong>二进制文件</strong>。</p><p>映像文件：内存中的二进制数据</p><p>ASCII文件又称文本文件：每一个字节放一个字符的ASCII码。</p><p>字符一律以ASCII码形式存储，数值型数据既可以用ASCII码形式存储也可以用二进制存储。</p><p>推荐使用二进制文件方便内存的读取和输出。</p><h3 id="10-1-4-文件缓冲区"><a href="#10-1-4-文件缓冲区" class="headerlink" title="10.1.4    文件缓冲区"></a>10.1.4    文件缓冲区</h3><p>ANSI C标准采用”缓冲文件系统”处理数据文件。</p><p>文件缓冲区：系统自动在内存区为程序每一个正在使用文件开辟一个文件缓冲区。</p><p>从内存向磁盘输出数据，先送到内存中的缓冲区，将装满缓冲区的数据送到磁盘中去，反之亦然。</p><p><img src="https://i.loli.net/2020/08/08/4BFMWXYpA6rfkP7.png" alt="文件缓冲区.png" loading="lazy"></p><h3 id="10-1-5-文件类型指针"><a href="#10-1-5-文件类型指针" class="headerlink" title="10.1.5    文件类型指针"></a>10.1.5    文件类型指针</h3><p>缓冲文件系统中，关键的概念是“文件类型指针”。</p><p>为方便起见，通常讲这种指向文件信息去的指针变量简称为指向文件的指针变量。</p><p>用结构体存储文件信息。该结构体由系统声明，取名为FILE。</p><pre><code class="c">typedef struct{    short level;                //缓冲区“满”或“空”的程度    unsigned flags;                //文件状态标识    char fd;                    //文件描述符    unsigned char hold;         //缓冲区无内容不读取字符    short bsize;                //缓冲区的大小    unsigned char * buffer;        //数据缓冲区的位置    unsigned char * curp;        //指针当前指向    unsigned istemp;            //临时文件指示器    short token；               //用于有效性检查}FILE;/*一般设置指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量，二部定义FILE类型变量，这样使用比较方便。*/</code></pre><h2 id="10-2-打开与关闭文件"><a href="#10-2-打开与关闭文件" class="headerlink" title="10.2    打开与关闭文件"></a>10.2    打开与关闭文件</h2><p>打开：为文件建立相应的信息区(存放有关文件的信息)和文件缓冲区(暂时存放输入输出的数据。)</p><h3 id="10-2-1-用fopen函数打开数据文件"><a href="#10-2-1-用fopen函数打开数据文件" class="headerlink" title="10.2.1    用fopen函数打开数据文件"></a>10.2.1    用fopen函数打开数据文件</h3><p>fopen函数的调用方式</p><p><strong>fopen(文件名，使用文件方式);</strong></p><pre><code class="c">FILE *fp;fp=fopen(&quot;a1&quot;,&quot;r&quot;);    //将fopen函数的返回值赋值给指针变量fp</code></pre><p><img src="https://i.loli.net/2020/08/08/dvrf1u2NTjXFhsV.png" alt="使用文件方式.png" loading="lazy"></p><p><img src="https://i.loli.net/2020/08/08/JB3rkamWFYNdew1.png" alt="使用文件方式2.png" loading="lazy"></p><p>注意：</p><ol><li>如果不能实现“打开”任务，返回值NULL</li><li>有些编译系统可能不完全提供所有这些功能(有的只能用”r”,”w”,”a”)，有的C版本不能用“r+”,”w+”,”a+”，而用“rw”，“wr”，“ar”时，看系统是否支持。</li><li>对于ASCII文件来说，遇到回车换行符，系统把它转换为一个换行符，在输出时吧吧换行符转换为回车和换行两个字符。二进制文件则不需要这要这种转换。</li><li>程序中可以使用3个标准的流文件——<strong>标准输入流、标准输出流、标准出错输出流</strong>系统对这3个文件制定了与终端的对应关系。</li><li>程序运行时自动打开3个标准流文件，系统定义了3个头文件指针变量<ul><li>stdin-&gt;标准输入流</li><li>stdout-&gt;标准输出流</li><li>stderr-&gt;标准出错输出流</li></ul></li></ol><h3 id="10-2-2-用fclose函数关闭数据文件"><a href="#10-2-2-用fclose函数关闭数据文件" class="headerlink" title="10.2.2    用fclose函数关闭数据文件"></a>10.2.2    用fclose函数关闭数据文件</h3><p>使用完一个文件后应该关闭它，防止被误用。</p><p>“关闭”就是 <strong>撤销文件信息区</strong>和 <strong>文件缓冲区</strong></p><p>关闭文件用fclose函数。</p><blockquote><p>fclose(文件指针);</p><p>fclose执行成功时返回0，否则返回EOF(-1)</p></blockquote><p>不关闭文件将会出现丢失数据，因为所修改的数据都还在缓冲区中，也就是在内存中，不在外部介质里。一旦程序结束，数据就会丢失。用fclose函数关闭文件，先把缓冲区中的数据写到文件，从而避免这个问题。应该养成在程序终止之前关闭所有文件的习惯。</p><h2 id="10-3-顺序读写数据文件"><a href="#10-3-顺序读写数据文件" class="headerlink" title="10.3    顺序读写数据文件"></a>10.3    顺序读写数据文件</h2><p>顺序读写：对文件读写数据的顺序和数据在文件中的物理顺序是一致的。</p><h3 id="10-3-1-怎么向文件读写字符"><a href="#10-3-1-怎么向文件读写字符" class="headerlink" title="10.3.1    怎么向文件读写字符"></a>10.3.1    怎么向文件读写字符</h3><table><thead><tr><th>函数名</th><th>调用形式</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>fgetc</td><td>fgetc(fp);//fp是文件指针</td><td>从fp指向的文件读入一个字符</td><td>读入成功，则返回所读字符；失败返回结束标志EOF(-1)</td></tr><tr><td>fputc</td><td>fputc(ch,fp);</td><td>把字符ch写到文件指针变量fp所指向的文件中</td><td>输出成功，返回输出的字符；输出失败，返回EOF(-1)</td></tr></tbody></table><pre><code class="c"># include&lt;stdio.h&gt;# include&lt;stdlib.h&gt;/*练习顺序输出字符*/int main(){    FILE *fp;    char ch,*filename;    printf(&quot;请输入所用的文件名:\n&quot;);    scanf(&quot;%s&quot;,filename);    if((fp=fopen(filename,&quot;w&quot;))==NULL)    {        printf(&quot;无法打开此文件\n&quot;);        exit(0);    }    ch=getchar();//用来接收最后输入的回车符 回车符此时在字符缓冲区内    printf(&quot;请输入一个准备存储到磁盘的字符串(以#结束):\n&quot;);    ch=getchar();//从字符缓冲区里读取字符    while(ch!=&#39;#&#39;)    {        fputc(ch,fp);//向磁盘文件输出字符        putchar(ch);//将字符输出终端上        ch=getchar();//接着从字符缓冲区里取字符    }    fclose(fp);//关闭文件    putchar(10);//向屏幕输出一个换行符    return 0;}</code></pre><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;stdlib.h&quot;/*练习读入文件*/int main(){    FILE *fp;    char ch,*filename;    printf(&quot;请输入文件名:\n&quot;);    scanf(&quot;%s&quot;,filename);    if((fp=fopen(filename,&quot;r&quot;))==NULL)    {        printf(&quot;文件打开错误，请重新尝试。\n&quot;);        exit(0);    }    ch=getchar();//将字符缓冲区中的回车符处理掉，避免对读取文件内容时造成干扰。    while(!feof(fp))//检查fp指向的文件是否结束，如果结束函数值为1(真)    {     ch=fgetc(fp);    //从文件中读取字符     putchar(ch);    }    fclose(fp);//关闭文件    putchar(10);//打印回车    return 0;}/*以上文件是按文本文件方式处理的，处理二进制文件是将读入/写出方式改为rb/wbC系统已把fputc和fgetc函数定义宏名为put和get# define putc(ch,fp) fputc(ch,fp)# define getc(ch,fp) fputc(ch,fp)这是在stdio.h中定义的，因此在程序中用putc和fputc作用是一样的。*/</code></pre><h3 id="10-3-2-怎样向文件读写一个字符串-避免了读入字符的麻烦"><a href="#10-3-2-怎样向文件读写一个字符串-避免了读入字符的麻烦" class="headerlink" title="10.3.2    怎样向文件读写一个字符串(避免了读入字符的麻烦)"></a>10.3.2    怎样向文件读写一个字符串(避免了读入字符的麻烦)</h3><p>C语言允许通过函数一次读写一个字符串。</p><table><thead><tr><th>函数名</th><th>调用形式</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>fgets</td><td>fgets(str,n,fp);</td><td>读入一个长度为n-1的字符串，存放字符串到数组str中。</td><td>读成功，返回地址str，失败返回NULL</td></tr><tr><td>fputs</td><td>fputs(str,fp);</td><td>把str所指向的字符串写到文件指针变量fp所指向的文件中</td><td>输出成功，返回0；否则返回非0值</td></tr></tbody></table><p>说明：</p><p>fgets函数原型:</p><p>char *fgets(char *str,int n,FILE *fp);//作用是读入字符串</p><p>n:代表要得到的字符个数，实际从文件中获得只有n-1个字符，因为最后一个字符作为字符串结束标志’\0’，这样把n个字符放到数组str中。</p><p>在读入n-1个字符前碰到’\n’或是文件结束符EOF，读入即结束，但是将所遇到的换行符’\n’也作为一个字符读入。</p><p>fputs函数原型为</p><p>int fputs(char *str,FILE *fp);</p><p>字符串末尾’\0’不会输出，输出成功函数值为0；失败时函数的值为EOF(-1)。</p><p>fgets和fputs这两个函数的功能类似于gets和puts函数，只是gets和puts以终端为读写对象，而fgets和fputs函数以指定的文件作为读写对象。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/*练习输出字符串*/# define LEN 3int main(){    FILE *fp;//需要读写的文件    char temp[20];//输入和输出的临时字符串    char str[3][20];//是用来存放字符串的二维数组    char filename[20];//输入文件名   字符指针指向字符串常量，不是字符串变量     int i,j;    printf(&quot;请输入想要输入的字符串:\n&quot;);    for (i = 0; i &lt;LEN; i++)//输入字符串    {        gets(str[i]);    }    for ( i = 0; i &lt; LEN-1;i++)//进行字符串大小    {        /* code */        for(j=i+1;j&lt;LEN;j++)            if (strcmp(str[i],str[j])&gt;0)            {                /* code */                strcpy(temp,str[i]);                strcpy(str[i],str[j]);                strcpy(str[j],temp);            }    }    printf(&quot;输入要打开的文件名\n&quot;);//    gets(filename);    scanf(&quot;%s&quot;,filename);    if ((fp=fopen(filename,&quot;w&quot;))==NULL)    {        printf(&quot;文件打开错误\n&quot;);        exit(0);    }    /* 进行字符串输出到文件中 */    for ( i = 0; i &lt;3; i++)    {        /* code */        fputs(str[i],fp);        fputs(&quot;\n&quot;,fp);        printf(&quot;%s\n&quot;,str[i]);    }    fclose(fp);    return 0;}</code></pre><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;/*练习读入字符串*/int main(){    FILE *fp;//定义文件指针变量    char str[3][20],filename[20];    int i;    printf(&quot;请输入打开文件名:\n&quot;);    scanf(&quot;%s&quot;,filename);     if((fp=fopen(filename,&quot;r&quot;))==NULL)    {        printf(&quot;文件打开错误！\n&quot;);        exit(0);    }    while(fgets(str[i],10,fp)!=NULL)    {        printf(&quot;%s&quot;,str[i]);        i++;    }    fclose(fp);//关闭文件    return 0;}/*1.打开文件时，文件名与路径不要输错2.fgets(str[i],10,fp) 读取字符串时，指定一次读入10个字符，当遇到&#39;\n&#39;,就结束字符串的输入。3.由于读入字符数组中的每个字符串后都一个&#39;\n&#39;,因此向屏幕输入时，不用加&#39;\n&#39;*/</code></pre><h3 id="10-3-3-用格式化的方式读写文件"><a href="#10-3-3-用格式化的方式读写文件" class="headerlink" title="10.3.3    用格式化的方式读写文件"></a>10.3.3    用格式化的方式读写文件</h3><p>如同printf和scanf函数一样，进行格式字符的输出和输入，printf和scanf是针对终端来说的。</p><p>对于文件来说，我们用fprintf和fscanf函数。一般调用形式为：</p><p><strong>fprintf(文件指针,格式字符串,输出表列);</strong></p><p><strong>fscanf(文件指针,格式字符串,输入表列);</strong></p><p>例如：</p><p>fprintf(fp,”%d,%f”,i,f);//作用是将int型变量i和float型变量f的值按%d和%f格式输出到fp指向的文件中。</p><p>fscanf(fp,”%d,%f”,&amp;i,&amp;f);//从磁盘文件中读入整数送给整形变量i,读取实数送给实型变量f</p><p>用fprintf和fscanf函数对磁盘文件读写，使用方便，容易理解。</p><p>输入时要将文件中的ASCII码转换为二进制形式在保存到内存变量中。</p><p>输出时又要将内存中的二进制形式转换成字符，需要花费许久时间。</p><p>在内存与磁盘频繁交换数据时，不推荐使用。</p><h3 id="10-3-4-用二进制方式项文件读写一组数据"><a href="#10-3-4-用二进制方式项文件读写一组数据" class="headerlink" title="10.3.4    用二进制方式项文件读写一组数据"></a>10.3.4    用二进制方式项文件读写一组数据</h3><p>C语言允许使用fread函数从文件中读一个数据块，用fwrite函数向文件中写一个数据块。在读写时是以二进制进行的。</p><p>一般调用形式：</p><pre><code class="markdown">fread(buffer,size,count,fp);//从文件中读fwrite(buffer,size,count,fp);//向文件中写1. buffer:是个地址。    对于fread来说用于存放从文件读入的数据存储区的地址    对于fwrite来说是把此地址开始的存储区中的数据向文件输出。2. size:读写的字节数3. count:要读写多少个数据项(每个数据长度为size)4. fp:FILE类型指针</code></pre><p>如：</p><p>fread(f,4,10,fp);//f是一个float数组，这个函数从fp所指向的文件读入10个4字节的数据存储到数组f中。</p><p>fread和fwrite函数的类型为int型，如果fread或fwrite函数执行成功，函数返回值为形参count的值。否则返回与count不相等的值</p><pre><code class="c"># include&lt;stdio.h&gt;# define SIZE 5/*练习二进制文件的与输出 */struct Student_type{    char name[10];    int num;    int age;    char addr[15];};void save(struct Student_type * stu){    FILE *fp;    char filename[20];    struct Student_type *st;    st=stu;    int i;    printf(&quot;请输入文件名\n&quot;);    scanf(&quot;%s&quot;,filename);    if((fp=fopen(filename,&quot;wb&quot;))==NULL)    {        printf(&quot;打开文件失败:\n&quot;);     }     for(i=0;i&lt;SIZE;i++,st++)    {        /*        结构体变量长度为它的成员长度之和，33但实际上是36字节，是4的倍数，系统以4个字节为一字        */        if(fwrite(st,sizeof(struct Student_type),1,fp)!=1)        printf(&quot;文件写入失败\n&quot;);     }      fclose(fp);}int main(){    int i;    struct Student_type stu[SIZE];    void save(struct Student_type * stu);    for(i=0;i&lt;SIZE;i++)    {        printf(&quot;Please enter data of students:\n&quot;);        scanf(&quot;%s %d %d %s&quot;,&amp;stu[i].name,&amp;stu[i].num,&amp;stu[i].age,&amp;stu[i].addr);    }    save(stu);    return 0;}</code></pre><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;stdlib.h&quot;# define SIZE 5;/*练习读取二进制文件*/struct Student_type{    char name[10];    int num;    int age;    char addr[15];};int main(){    int i;    FILE *fp;    char filename[20];    printf(&quot;请输入文件名\n&quot;);    scanf(&quot;%s&quot;,filename);    if((fp=fopen(filename,&quot;rb&quot;))==NULL)    {        printf(&quot;打开文件失败:\n&quot;);        exit(0);     }    for(i=0;i&lt;SIZE;i++)    {         fread(&amp;stu[i],sizeof(struct Student_type),1,fp);         printf(&quot;%s\t%d\t%dt\t%s\n&quot;,&amp;stu[i].name,&amp;stu[i].num,&amp;stu[i].age,&amp;stu[i].addr);     }    fclose(fp);    return 0;}</code></pre><h2 id="10-4-随机读写数据文件"><a href="#10-4-随机读写数据文件" class="headerlink" title="10.4    随机读写数据文件"></a>10.4    随机读写数据文件</h2><h3 id="10-4-1-文件位置标记及其定位"><a href="#10-4-1-文件位置标记及其定位" class="headerlink" title="10.4.1    文件位置标记及其定位"></a>10.4.1    文件位置标记及其定位</h3><h4 id="1-文件位置标记"><a href="#1-文件位置标记" class="headerlink" title="1.文件位置标记"></a>1.文件位置标记</h4><p>系统为每个文件设置了一个文件读写位置标记(简称 <strong>文件位置标记</strong> 或 <strong>文件标记</strong>)：用来指示”接下来读写下一个字符的位置“。</p><p>顺序读取时文件标记指向文件头，这时对文件内容依次读入，文件标记就依次向后移动，直到文件末尾。</p><p>顺序写文件时与读文件类似，把所有数据写完，文件标记在最后一个数据之后。</p><p>根据读写需要，人为地移动文件位置标记的位置。就是随机读写。随机读写对文件读写数据的顺序和数据在文件中的物理顺序是不一致的。(读写位置，读写内容)</p><p>流式文件既可以进行顺序读写也可以进行随机读写。</p><h4 id="2-文件位置标记的定位"><a href="#2-文件位置标记的定位" class="headerlink" title="2.文件位置标记的定位"></a>2.文件位置标记的定位</h4><p>可以强制是文件标记位置指向人们指定的位置。可以用以下函数实现。</p><h5 id="1-rewind函数使文件位置标记指向文件开头。没有返回值"><a href="#1-rewind函数使文件位置标记指向文件开头。没有返回值" class="headerlink" title="1.rewind函数使文件位置标记指向文件开头。没有返回值"></a>1.rewind函数使文件位置标记指向文件开头。没有返回值</h5><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;int main(){    FILE *fp1,*fp2;    //文件打开检查    if((fp1=fopen(&quot;text.txt&quot;,&quot;r&quot;))==NULL)    {        printf(&quot;text.txt打开错误\n&quot;);        exit(0);    }    if((fp2=fopen(&quot;file2.dat&quot;,&quot;w&quot;))==NULL)    {        printf(&quot;file2.dat打开错误\n&quot;);        exit(0);    }    while(!feof(fp1))    putchar(getc(fp1));//输出从text中读取到的字符     putchar(10);//回车符     rewind(fp1);//使文件标记位置回到文件头     while(!feof(fp1))    putc(getc(fp1),fp2);//从文件头中重新逐个读字符,输出file2文件     fclose(fp1);    fclose(fp2);    return 0;}</code></pre><h5 id="2-用fseek函数改变文件位置标记"><a href="#2-用fseek函数改变文件位置标记" class="headerlink" title="2.用fseek函数改变文件位置标记"></a>2.用fseek函数改变文件位置标记</h5><p>fseek函数的调用形式：</p><p>fseek(文件类型指针,位移量,起始点);</p><p>起始点：</p><ol><li>0代表文件开始位置</li><li>1代表当前位置</li><li>2文件末尾位置</li></ol><p>位移量：以起始点为基点，向前移动的字节数。位移量应是long型数据</p><p>fseek函数一般用于二进制文件，例如：</p><p>fseek(fp,100L,0);          //将文件位置标记向前移动离文件开头100个字节处</p><p>fseek(fp,50L,1);            //将文件位置标记向前移动离当前位置50个字节处</p><p>fseek(fp,-100L,2);        //将文件位置标记从文件末尾向后退10个字节</p><h5 id="3-用ftell函数测定文件位置标记的当前位置。"><a href="#3-用ftell函数测定文件位置标记的当前位置。" class="headerlink" title="3.用ftell函数测定文件位置标记的当前位置。"></a>3.用ftell函数测定文件位置标记的当前位置。</h5><p>ftell函数的作用是得到流式文件中文件位置的当前位置。</p><p>用相对文件开头的位移量表示返回值，如果函数调用出错，ftell函数返回值为-1L</p><p>如：</p><pre><code class="c">i=ftell(fp);//变量i存放文件当前位置if(i==-1L)    printf(&quot;error\n&quot;);//如果调用函数时出错，输出error</code></pre><h3 id="10-4-2-随机读写"><a href="#10-4-2-随机读写" class="headerlink" title="10.4.2    随机读写"></a>10.4.2    随机读写</h3><pre><code class="c"># include &lt;stdio.h&gt;# include &quot;stdlib.h&quot;# define SIZE 10/*练习随机读写 */struct Student_type{    char name[10];    int num;    int age;    char addr[20]; }stud[SIZE];int main(){    int i;    FILE *fp;    if((fp=fopen(&quot;stu.dat&quot;,&quot;rb&quot;))==NULL)    {        printf(&quot;can not open file\n&quot;);        exit(0);    }    for(i=0;i&lt;10;i+=2)    {        fseek(fp,i*sizeof(struct Student_type),0);        fread(&amp;stud[i],sizeof(struct Student_type),1,fp);        printf(&quot;%-10s %4d %4d %-15s\n&quot;,stud[i].name,stud[i].num,stud[i].age,stud[i].addr);    }    fclose(fp);    return 0; } </code></pre><h3 id="10-5-文件读写的出错检测"><a href="#10-5-文件读写的出错检测" class="headerlink" title="10.5    文件读写的出错检测"></a>10.5    文件读写的出错检测</h3><p>1.ferror函数</p><p>用于检测各种输入输出函数，如：putc,getc,fread,fwrite等等</p><p>ferror(fp);</p><p>如果返回值为0，表示未出错，返回非0数值，表示出错。</p><p>每次调用输入输出函数，都会产生新的ferror函数值。</p><p>执行fopen函数时，ferror函数的初始值自动设置为0</p><p>2.clearerr函数</p><p>用于使文件错误标志和文件结束标志置为0。比如说：当调用一个输入输出函数出现错误，ferror函数值为一个非零的值。应立即调用clearerr(fp),使ferror(fp)的值变成0，以便下一次检测。</p><p>只要出现文件读写错误标志，它就会一直保留，直到对同一文件调用clearerr函数或是rewind函数，或是其他任何一个输入输出函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-vJVBbCqk&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;10-1-C文件的有关基本知识&quot;&gt;&lt;a href=&quot;#10-1-C文件的有关基本知识&quot; class=&quot;headerlink&quot; title=&quot;10.1    C文件的有关基本知识&quot;&gt;&lt;/a&gt;10.1    C文件的有关基本知识&lt;/h2&gt;&lt;h3 id=&quot;10-1-1-什么是文件&quot;&gt;&lt;a href=&quot;#10-1-1-什么是文件&quot; class=&quot;headerlink&quot; title=&quot;10.1.1    什么是文件&quot;&gt;&lt;/a&gt;10.1.1    什么是文件&lt;/h3&gt;&lt;p&gt;程序设计中主要用到两种文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序文件。源文件，目标文件，可执行文件，文件内容为程序代码&lt;/li&gt;
&lt;li&gt;数据文件。文件内容不是不是程序代码，是程序文件运行时读写的数据。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>用户自己建立数据类型</title>
    <link href="https://www.nscblog.top/posts/7cad0bc5/"/>
    <id>https://www.nscblog.top/posts/7cad0bc5/</id>
    <published>2020-06-20T16:15:28.000Z</published>
    <updated>2020-08-23T06:12:28.797Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-mhNhJsME" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="9-1-定义和使用结构体变量"><a href="#9-1-定义和使用结构体变量" class="headerlink" title="9.1    定义和使用结构体变量"></a>9.1    定义和使用结构体变量</h2><h3 id="9-1-1-自己建立结构体类型"><a href="#9-1-1-自己建立结构体类型" class="headerlink" title="9.1.1    自己建立结构体类型"></a>9.1.1    自己建立结构体类型</h3><p>C语言允许用户自己建立由不同类型数据组成的复合型数据结构，它称为结构体。</p><a id="more"></a><pre><code class="c">struct Student{int num;char name[20];char sex;int age;float age;float score;char addr[30];};                    /*struct是声明结构体类型的关键字，不能省略。*/</code></pre><p>声明一个结构体类型的一般形式为：</p><blockquote><p>struct 结构体名</p><p>​    {成员列表};</p></blockquote><p>注意：</p><p>1.结构体类型的名字是由一个关键字struct和结构体名组合成的(例如：struct Student)</p><p>2.结构体名，如：Student(结构体名又叫结构体标记)</p><p>3.花括号内的子项，称为结构体成员，对成员都应进行类型声明</p><p>4.结构体类型可以有多种，成员可以属于另一个结构体类型。</p><pre><code class="c">struct Date{int month;int year;int day;};struct Student{int num;char name[20];char sex;int age;float age;float score;char addr[30];struct Date birthday;            //成员birthday属于struct Date类型}</code></pre><p>模型图</p><p><img src="https://i.loli.net/2020/08/08/ybkrojAaMODePsE.png" alt="结构体模型图.png" loading="lazy"></p><h3 id="9-1-2-定义结构体类型变量"><a href="#9-1-2-定义结构体类型变量" class="headerlink" title="9.1.2    定义结构体类型变量"></a>9.1.2    定义结构体类型变量</h3><p>结构体被定义声明后，没有使用，系统对之不分配存储单元。</p><p>定义结构类型变量：</p><ol><li><p>先声明结构体类型，再定义该类型的变量</p><p>如：struct Student(结构体类型名) student1,student2(结构体变量名);</p><p>定义结构体变量后，系统会为之分配内存单元。</p></li><li><p>在声明类型的同时定义变量</p><pre><code class="c">struct Student{int num;char name[20];char sex;int age;float age;float score;char addr[30];} student1,student2;/*在写大程序时，往往要求对类型的声明和对变量的定义分别放在不同的地方，以便程序结构清晰，便于维护，一般不采用这种方式。*/</code></pre></li><li><p>不指定类型名而直接定义结构体类型变量</p><p>一般形式：</p><pre><code class="c">struct{成员列表} 变量名列表;/*说明：    1.结构体类型和结构体变量是不同的东西，只能对变量赋值，在编译时，只对变量分配空间。    2.结构体类型成员名可以与程序中变量名相同    3.结构体变量中的成员，可以单独使用，作用相当于普通变量*/</code></pre></li></ol><h3 id="9-1-3-结构体变量的初始化和引用"><a href="#9-1-3-结构体变量的初始化和引用" class="headerlink" title="9.1.3    结构体变量的初始化和引用"></a>9.1.3    结构体变量的初始化和引用</h3><p>在定义结构体变量时，可以对它初始化，即赋予初始值，然后引用这个变量。</p><pre><code class="c"># include &quot;stdio.h&quot;int main (){    struct Student            //定义声明结构体Student    {    int num;    char name[20];    char sex;    char addr[30];    };    struct Student stu={101,&quot;ahuang&quot;,&#39;W&#39;,&quot;123 Beijing Road&quot;};//进行初始化赋值    printf(&quot;No.:%d\nname:%s\nsex:%c\naddr:%s\n&quot;,stu.num,stu.name,stu.sex,stu.addr);    return 0;}/*1. 进行初始化时，初始化列表使用花括号括起来的一些常量。    C99标准允许对某一成员初始化。如：    struct Studnet stu={.name=&quot;xiehuangbao&quot;};    其他数值型被初始化为0，字符型被初始化为&#39;\0&#39;,指针变量被初始化为NULL2. 可以引用结构体变量中的值，引用方式：结构体变量名.成员名    如：stu.num=10001;//在程序中对变量的成员赋值。    .  是成员运算符，它在所有运算符中优先级最高，因此可以把stu.num作为一个整体看待，相当于一个变量    注意：不能通过输出结构体变量名输出结构体变量所有成员的值3. 如果成员本身又是一个结构体类型，则要用若干个成员运算符，一级一级找到最低的一级的成员。只能对最低级的成员进行赋值或存取以及运算。    stu.num            //访问stu成员num    stu.birthday.month    //访问stu成员中的成员month4. 对结构体变量的成员可以向普通变量一样进行各种运算(根据其类型决定可以进行的运算)。5. 同类的结构体变量可以进行相互赋值，如：    stu1=stu26. 可以引用结构体变量成员的地址，也可以引用结构体变量的地址。例如：    scanf(&quot;%d&quot;,&amp;stu.num);    //输入&amp;stu.num的值    printf(&quot;%o&quot;,&amp;stu);        //输出结构体变量&amp;stu的首地址    scanf(&quot;%d,%s,%c,%d,%f,%s\n&quot;,&amp;stu);//不能用这样的语句读入结构体变量    结构体变量的地址主要用作函数参数，传递结构体变量地址。*/</code></pre><pre><code class="c"># include &quot;stdio.h&quot;/*定义和使用结构体 */int main(){    struct Student{        //定义和声明结构体Student         int num;//学号        char name[20];        float score;     };    struct Student stu1,stu2;    scanf(&quot;%d%s%f&quot;,&amp;stu1.num,stu1.name,&amp;stu1.score);    scanf(&quot;%d%s%f&quot;,&amp;stu2.num,stu2.name,&amp;stu2.score);    if(stu1.score&gt;stu2.score) printf(&quot;%d\t%s\t%f\n&quot;,stu1.num,stu1.name,stu1.score);    if(stu1.score&lt;stu2.score) printf(&quot;%d\t%s\t%f\n&quot;,stu2.num,stu2.name,stu2.score);    if(stu1.score=stu2.score)     {        printf(&quot;%d\t%s\t%f\n&quot;,stu1.num,stu1.name,stu1.score);        printf(&quot;%d\t%s\t%f\n&quot;,stu2.num,stu2.name,stu2.score);    }    return 0;  } </code></pre><h2 id="9-2-使用结构体数组"><a href="#9-2-使用结构体数组" class="headerlink" title="9.2    使用结构体数组"></a>9.2    使用结构体数组</h2><h3 id="9-2-1-定义结构体数组"><a href="#9-2-1-定义结构体数组" class="headerlink" title="9.2.1    定义结构体数组"></a>9.2.1    定义结构体数组</h3><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;/*    定义和引用结构体数组 */int main(){    struct Person            //声明结构体 struct Person     {        char name[20];        int count;    };    struct Person leader[3]={            //定义结构体数组并初始化         &quot;Li&quot;,0,&quot;Zhang&quot;,0,&quot;Sun&quot;,0    };    int i,j;    char lead_name[20];    for(i=1;i&lt;=10;i++)    {        scanf(&quot;%s&quot;,lead_name);        for(j=0;j&lt;3;j++)        if(!strcmp(lead_name,leader[j].name))leader[j].count++;    }    for(i=0;i&lt;3;i++)        printf(&quot;%s\t%d\n&quot;,leader[i].name,leader[i].count);    return 0; }</code></pre><p>说明：</p><p>1.定义结构体数组一般形式是</p><ul><li>struct 结构体名{成员列表} 数组名[数组长度];</li><li>先声明一个结构体类型，再用此类型定义结构体数组；</li></ul><p>2.对结构体数组初始化的形式是在定义数组的后面加上：={初值列表};</p><p>​    如：</p><p>​    struct Person leader[3]={            //定义结构体数组并初始化<br>​        “Li”,0,”Zhang”,0,”Sun”,0<br>​    };</p><h3 id="9-2-2-结构体数组的应用举例"><a href="#9-2-2-结构体数组的应用举例" class="headerlink" title="9.2.2    结构体数组的应用举例"></a>9.2.2    结构体数组的应用举例</h3><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;/*    定义和引用结构体数组 */int main(){    struct Student            //声明结构体 struct Person     {        int num;        char name[20];        float score;    };    struct Student stu[5]={            //定义结构体数组并初始化         10101,&quot;Zhang&quot;,78,        10103,&quot;Wang&quot;,98.5,        10106,&quot;Li&quot;,86,        10108,&quot;Ling&quot;,73.5,        10110,&quot;Sun&quot;,100    };    struct Student temp;//临时交换存储变量     int i,j;    for(i=0;i&lt;=5-1;i++)        for(j=i;j&lt;5;j++)        {            if(stu[i].score&gt;stu[j].score)            {                temp=stu[i];                stu[i]=stu[j];                stu[j]=temp;            }        }    for(i=0;i&lt;5;i++)        printf(&quot;%d\t%d\t%f\n&quot;,stu[i].num,stu[i].name,stu[i].score);    return 0; }</code></pre><p>说明：</p><ol><li>在定义结构体数组进行初始化时，将每个学生的信息用一对花括号包起来，这样做，阅读和检查比较方便。（提供程序的可读性）</li><li>注意临时变量temp定义为struct Student类型，只有同类型的结构体变量才能互相赋值，不必人为指定一个一个成员互换，这体现了结构体类型的好处。</li></ol><h2 id="9-3-结构体指针"><a href="#9-3-结构体指针" class="headerlink" title="9.3    结构体指针"></a>9.3    结构体指针</h2><h3 id="9-3-1-指向结构体变量的指针"><a href="#9-3-1-指向结构体变量的指针" class="headerlink" title="9.3.1    指向结构体变量的指针"></a>9.3.1    指向结构体变量的指针</h3><p>指针变量的基类型必须与结构体变量的类型相同。</p><p>例如：struct Student *p;</p><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;/*    了解什么是指向结构体变量的指针变量以及     怎么使用该类型的指针变量 */int main(){    struct Student    {        int num;        char name[20];        char sex;        int age;    };    struct Student stu,* p;    p=&amp;stu;    stu.num=10101;    strcpy(stu.name,&quot;LiLin&quot;);    stu.sex=&#39;M&#39;;    stu.age=25;    printf(&quot;No.:%d\nname:%s\nsex:%c\nage:%d\n&quot;,stu.num,stu.name,stu.sex,stu.age);     printf(&quot;No.:%d\nname:%s\nsex:%c\nage:%d\n&quot;,(*p).num,(*p).name,(*p).sex,(*p).age);    return 0; } /*如果一个p指向一个结构体变量stu，以下3种方法等价：1.stu.成员名(如：stu.num);2.(*p).成员名((*p).num);3.p-&gt;成员名(如p-&gt;num).        -&gt;称为指向运算符*/</code></pre><h3 id="9-3-2-指向结构体数组的指针"><a href="#9-3-2-指向结构体数组的指针" class="headerlink" title="9.3.2    指向结构体数组的指针"></a>9.3.2    指向结构体数组的指针</h3><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;string.h&gt;/*    初步了解指向结构体数组的指针 */int main(){    struct Student{        int num;        char name[20];        char sex;        int age;    };    struct Student stu[3]={        {10101,&quot;LiLin&quot;,&#39;M&#39;,18}       ,{10102,&quot;ZhangFang&quot;,&#39;M&#39;,19}       ,{10103,&quot;WangMin&quot;,&#39;F&#39;,20}    };                //定义结构体数组并初始化     struct Student *p;    for(p=stu;p&lt;stu+3;p++)    //使指向stu数组的第一个元素         printf(&quot;%d\t%s\t%c\t%d\n&quot;,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age);    return 0;}/*注意：1.程序定义了p是指向struct Student类型的指针变量，它用来指向一个struct Student类型的对象，但是不能指向stu数组元素中的某一成员。2.如果要将某一成员地址赋值给p，可以使用强制类型转换。如：p=(struct Student *)stu[0].name;*/</code></pre><h3 id="9-3-3-用结构体变量和结构体变量的指针作函数参数"><a href="#9-3-3-用结构体变量和结构体变量的指针作函数参数" class="headerlink" title="9.3.3    用结构体变量和结构体变量的指针作函数参数"></a>9.3.3    用结构体变量和结构体变量的指针作函数参数</h3><p>将一个结构体变量的值传递给另一个函数，有3种方法：</p><ol><li>用结构体变量的成员作参数</li><li>用结构体变量作实参。结构体作实参时，采取的也是值“传递方式”，形参也必须是同类型的结构提提变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，且因采用值传递的方式，如果在执行期间，形参改变的haul，该值是无法返回给主调函数的，这往往造成使用上的不便。</li><li>用指向结构体变量的指针作实参。传递地址（推荐：减少内存开销，避免用结构体作实参的缺陷）。</li></ol><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;# include &quot;stdlib.h&quot; /*    了解和使用结构体变量和结构体指针作函数参数     有结构体变量，成员是学号，姓名，3门课成绩。输出平均成绩最高的学生信息 */ # define N 3 //定义有3个学生 struct Student{        int num;        char name[20];        float score1;        float score2;        float score3;        float aver;    }; int main (){    struct Student stu[N],*p,student;    int i=0;    void input_information(struct Student *p);    struct Student * max_aver(struct Student stu[]);    p=stu;//指向首个元素     input_information(p);     //输入学生数据     for(;i&lt;N;i++)            //输出输入的学生信息         printf(&quot;%d\t%s\t%f\t%f\t%f\t%f\t\n&quot;,stu[i].num,stu[i].name,stu[i].score1,stu[i].score2,stu[i].score3,stu[i].aver);    p=max_aver(p);    printf(&quot;%d\t%s\t%f\t%f\t%f\t%f\t\n&quot;,p-&gt;num,p-&gt;name,p-&gt;score1,p-&gt;score2,p-&gt;score3,p-&gt;aver);//输出最高平均学生信息     return 0;}void input_information(struct Student *p){    int i=0;    for(;i&lt;N;p++,i++)    {        printf(&quot;请输入学生信息:\n&quot;);        scanf(&quot;%d%s%f%f%f&quot;,&amp;(p-&gt;num),&amp;(p-&gt;name),&amp;(p-&gt;score1),&amp;(p-&gt;score2),&amp;(p-&gt;score3));        p-&gt;aver=(p-&gt;score1+p-&gt;score2+p-&gt;score3)/3;    }}struct Student * max_aver(struct Student stu[]){    int i=0;    struct Student * student;    for(;i&lt;N-1;i++)        if(stu[i].aver&gt;stu[i+1].aver)            student=&amp;stu[i];        else            student=&amp;stu[i+1];    return student;}</code></pre><h2 id="9-4-用指针处理链表"><a href="#9-4-用指针处理链表" class="headerlink" title="9.4    用指针处理链表"></a>9.4    用指针处理链表</h2><h3 id="9-4-1-什么是链表"><a href="#9-4-1-什么是链表" class="headerlink" title="9.4.1    什么是链表"></a>9.4.1    什么是链表</h3><p>链表是一种常见的重要的数据结构。它是动态的进行存储分配的一种结构。</p><p>链表根据需要开辟内存单元。</p><p>链表有一个“头指针”变量，它存放一个地址，该地值指向一个元素。链表中每个元素称为“结点”</p><p>每个结点应该包括两个部分：</p><ol><li>用户需要用的实际数据；</li><li>下一个结点的地址。最后一个元素的地址部分存放NULL表示链表到此结束</li></ol><p>链表元素在内存中的地址可以是不连续的。</p><p>找一个元素，必须知道上一个元素存放该元素的地址。没有头指针整个链表无法访问。</p><p>链表必须利用指针变量才能实现。一个姐弟啊应包含一个指针变量，用它存放下一个结点的地址。</p><pre><code class="c">/*可以设计这样的结构体类型*/struct Student{int num;float score;struct Student * next;   //next是指针变量，指向结构体变量（即下一个元素地址）};/*num和score   是存放的实际数据next  是下一个元素地址一个指针类型的成员既可以指向其他类型的结构体数据，也可以指向自身所在的结构体类型的数据。*/</code></pre><h3 id="9-4-2-建立简单的静态链表"><a href="#9-4-2-建立简单的静态链表" class="headerlink" title="9.4.2    建立简单的静态链表"></a>9.4.2    建立简单的静态链表</h3><pre><code class="c"># include &quot;stdio.h&quot;/*建立简单的静态链表 */int main (){    struct Student            //定义声明一个结构体     {        int num;        float score;        struct Student * next;        };    //定义结构体变量以及指针变量     struct Student stu1,stu2,stu3,*p1,*p2,*head;     p1=&amp;stu2;    p2=&amp;stu3;     //进行赋值操作    stu1.num=10101;    stu1.score=56.5;    stu1.next=p1;    stu2.num=10310;    stu2.score=66.5;    stu2.next=p2;    stu3.num=10102;    stu3.score=55.0;    stu3.next=NULL;    //没有头指针，链表无法访问    head=&amp;stu1;     do    {        printf(&quot;%d\t%f\n&quot;,head-&gt;num,head-&gt;score);        head=head-&gt;next;    }while(head!=NULL);    return 0; } /*head头指针指向stu1,stu.next指向了stu2，stu2.next指向stu3,stu3.next=NULL表示这个末尾元素，每个元素中都有实际数据，且每个元素中都有下一个元素地址，这就形成了简单的链表关系静态链表：结点是在程序中定义的，不是临时开辟的，也不能用完后释放。*/ </code></pre><h3 id="9-4-3-建立动态链表"><a href="#9-4-3-建立动态链表" class="headerlink" title="9.4.3    建立动态链表"></a>9.4.3    建立动态链表</h3><p>动态链表是指在程序执行过程中建立一个链表</p><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;stdlib.h&quot;/*    建立动态链表 */struct Student            //定义声明一个结构体     {        int num;        float score;        struct Student * next;        };int main (){    struct Student * pt;    struct Student * creat();    pt=creat();    printf(&quot;%d\t%f\n&quot;,pt-&gt;num,pt-&gt;score);    return 0; } struct Student * creat(){    struct Student *head,*p1,*p2;    head=NULL;//先使头指针指向空 ，表示现在的链表是个空链表     int n=0;//表示结点个数    p1=p2=(struct Student *)malloc(sizeof(struct Student));//开辟第一个结点，将地址赋值给p1,p2    printf(&quot;请分别输入学号和成绩:\n&quot;);    scanf(&quot;%d%f&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score);//输入实际数据     while(p1-&gt;num!=0)     {        n+=1;        if(n==1)            head=p1;//表示创建一个新的链表。 当n==1时         else{            p2-&gt;next=p1;//存放下个结点的地址         }        p2=p1;//指向同一个结点         p1=(struct Student *)malloc(sizeof(struct Student));//开辟新的结点         printf(&quot;请分别输入学号和成绩:\n&quot;);        scanf(&quot;%d%f&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score);//输入实际数据     }     p2-&gt;next=NULL;//没有创建结点，表示表尾     return head;}</code></pre><h3 id="9-4-4-输出链表"><a href="#9-4-4-输出链表" class="headerlink" title="9.4.4    输出链表"></a>9.4.4    输出链表</h3><p>将链表中各结点的数据依次输出。</p><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;stdlib.h&quot;/*    建立动态链表 */struct Student            //定义声明一个结构体     {        int num;        float score;        struct Student * next;        };int main (){    struct Student * pt;    struct Student * creat();    void printf_linked_list(struct Student * head);    pt=creat();    printf_linked_list(pt);    return 0; } struct Student * creat(){    struct Student *head,*p1,*p2;    head=NULL;//先使头指针指向空 ，表示现在的链表是个空链表     int n=0;    p1=p2=(struct Student *)malloc(sizeof(struct Student));//开辟第一个结点，将地址赋值给p1,p2    printf(&quot;请分别输入学号和成绩:\n&quot;);    scanf(&quot;%d%f&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score);//输入实际数据     while(p1-&gt;num!=0)     {        n+=1;        if(n==1)            head=p1;//表示创建一个新的链表。 当n==1时         else{            p2-&gt;next=p1;//存放下个结点的地址         }        p2=p1;//指向同一个结点         p1=(struct Student *)malloc(sizeof(struct Student));//开辟新的结点         printf(&quot;请分别输入学号和成绩:\n&quot;);        scanf(&quot;%d%f&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score);//输入实际数据     }     p2-&gt;next=NULL;//没有创建结点，表示表尾     return head;}void printf_linked_list(struct Student * head){    struct Student * pt;    pt=head;    if(head!=NULL)            //判断头指针是否为空，为空的话，链表无法访问        while(pt!=NULL)        {            printf(&quot;%d\t%f\n&quot;,pt-&gt;num,pt-&gt;score);            pt=pt-&gt;next;        }} </code></pre><h2 id="9-5-共用体类型"><a href="#9-5-共用体类型" class="headerlink" title="9.5    共用体类型"></a>9.5    共用体类型</h2><h3 id="9-5-1-什么是共用体类型"><a href="#9-5-1-什么是共用体类型" class="headerlink" title="9.5.1    什么是共用体类型"></a>9.5.1    什么是共用体类型</h3><p>在同一个地址上，使用覆盖技术，后一个数据覆盖了前面的数据。这种使几个不同的变量共享同一段内存结构，称为“共用体”类型的结构。</p><p>共用体类型一般定义形式：</p><blockquote><p>union 共用体名</p><p>{成员列表} 变量表列；</p></blockquote><p>定义声明和定义变量与结构体相同。但是含义不一样：</p><p><strong>共用体变量所占的内存长度等于最长成员的长度。</strong></p><h3 id="9-5-2-引用共用体变量的方式"><a href="#9-5-2-引用共用体变量的方式" class="headerlink" title="9.5.2    引用共用体变量的方式"></a>9.5.2    引用共用体变量的方式</h3><p> 必须先定义共用体变量，后引用。注意引用的是共用体的成员，不是共用体变量。</p><p>例如：</p><pre><code class="c">union Data        //声明定义一个共用体{int I;char ch;float f;};union Data a,b,c;    //用共用体类型定义变量a.I                    //引用共用体成员，是正确的a.cha.fprintf(&quot;%d&quot;,a);        //这样是错误的，不能引用共用体变量。printf(&quot;%d&quot;,a.I);    //可以写成这样/*union        //这样也可以声明定义  {int i;char ch;float f;}a,b,c;*/</code></pre><h3 id="9-5-3-共用体类型数据的特点"><a href="#9-5-3-共用体类型数据的特点" class="headerlink" title="9.5.3    共用体类型数据的特点"></a>9.5.3    共用体类型数据的特点</h3><p>使用共用体类型数据是要注意以下一些特点：</p><ol><li><p>同一个内存段可以用来存放几种不同类型的成员。在每一瞬时，只能存放一个成员，也就是说，共同体变量只能存放一个值。</p><pre><code class="c">union Date{int i;char ch;float f;};union Date a;a.i=97;//表示将整数97存放在共用体变量中，可以用以下输出语句：printf(&quot;%d&quot;,a.i);        //输出整数97printf(&quot;%c&quot;,a.ch);        //输出字符aprintf(&quot;%f&quot;,a.f);        //输出实数0.000000</code></pre></li><li><p>可以对共用体变量初始化，但初始化表中有一个常量。</p><pre><code class="c">union Data{int i;char ch;float f;}a={1,&#39;a&#39;,1.5};        //不能初始化3个成员，它们占用同一段存储单元union Data a={16};    //正确，对第一个成员初始化union Data a={.ch=&#39;j&#39;};//C99允许对指定的一个成员初始化</code></pre></li><li><p>共用体变量中起作用的成员是最后一次被赋值的成员，在共用体变量中的成员赋值后，原来变量存储单元中的值就被取代。</p></li><li><p>共用体变量的底子和它的各成员的地址都是相同的，因为共用同一块内存段。</p></li><li><p>不能对共用体变量名赋值，不能企图引用变量名来得到一个值。</p><p>​    C99允许同类型的共用体变量互相赋值。</p><p>a=b；        //a和b同类型的共用体变量，合法</p></li><li><p>C99之前规定共用体变量不能作为函数参数，但可以使用指向共用体变量的指针作函数参数。C99允许共用体变量作函数参数。</p></li><li><p>共用体可以出现在结构体类型定义中，数组可以作为共用体成员。</p></li></ol><blockquote><p>什么时候会用到共用体呢？</p><p>处理数据是，有时需要对同一段空间安排不同的用途。</p></blockquote><p>例如：</p><pre><code class="c"># include &quot;stdio.h&quot;/*共用体的简单使用场景 */struct {        int num;        char name[10];        char sex;        char job;        union        {            int clazz;            char position[10];        } category;    }person[2];int main(){    int i=0;    for(;i&lt;2;i++)    {        printf(&quot;请输入当前人的信息:\n&quot;);        scanf(&quot;%d %s %c %c&quot;,&amp;person[i].num,&amp;person[i].name,&amp;person[i].sex,&amp;person[i].job);        if(person[i].job==&#39;s&#39;)//判断是学生还是老师            scanf(&quot;%d&quot;,&amp;person[i].category.clazz);//是学生输入相应的班级        else if(person[i].job==&#39;t&#39;)            scanf(&quot;%s&quot;,person[i].category.position);//是老师的话，输入相应的职位        else            printf(&quot;输入信息有误\n&quot;);     }    for(i=0;i&lt;2;i++)    {        if(person[i].job==&#39;s&#39;)            printf(&quot;%d\t%s\t%c\t%c\t%d\n&quot;,person[i].num,person[i].name,person[i].sex,person[i].job,person[i].category.clazz);        if(person[i].job==&#39;t&#39;)            printf(&quot;%d\t%s\t%c\t%c\t%s\n&quot;,person[i].num,person[i].name,person[i].sex,person[i].job,person[i].category.position);    }    return 0; } </code></pre><h2 id="9-6-使用枚举类型"><a href="#9-6-使用枚举类型" class="headerlink" title="9.6    使用枚举类型"></a>9.6    使用枚举类型</h2><p>一个变量只要几种可能的值，则可以定义为枚举类型。</p><p>枚举：把可能的值一一列举出来，变量值只限于列举出来的值的范围内。</p><p>例如：</p><p>enum Weekday {sun,mon,tue,wed,thu,fri,sat};</p><p>Weekday 是枚举变量 </p><p>{枚举元素或是枚举常量}</p><p>声明枚举类型的一般形式为：</p><blockquote><p>enum [枚举名]{枚举元素列表}；</p></blockquote><p>说明：</p><p>1.C编译对枚举类型的枚举元素按常量处理，故称为枚举常量</p><p>2.每个枚举元素都代表一个整数，C语言编译按定义时顺序默认它们的值为0,1,2,3…</p><p>例如： Weekday=mon； 相当于 Weekday=1;</p><p>3.枚举元素可以用来作判断比较。</p><p>下面我们用一个例子来介绍枚举类型的使用。</p><pre><code class="c"># include &quot;stdio.h&quot;/*简单了解枚举类型的使用*/int main(){    enum Color{red,yellow,blue,white,black};//定义枚举类型  枚举元素是常量 每个元素代表一个整数    enum Color i,j,k,pri;//定义枚举变量    int n=0,loop;//loop 是循环的层数    for ( i = red; i &lt;=black; i++)//第一次摸球    {        /* code */        for ( j = red; i &lt;=black; i++)        {            /* code */            if (i!=j)            {                /* code */                for(k=red;k&lt;=black;k++)                {                    if (k!=i&amp;&amp;k!=j)                    {                        /* code */                        n+=1;//开始统计有几中摸球方法数量                        // printf(&quot;一共有%d摸球方法&quot;,n);                        for ( loop = 1; loop &lt;=3; loop++)                        {                            /* code */                            switch (loop)                            {                            case 1/* constant-expression */:                                pri=i;                                /* code */                                break;                            case 2/* constant-expression */:                                pri=j;                                /* code */                                break;                            case 3/* constant-expression */:                                pri=k;                                /* code */                                break;                            default:                                break;                            }                            switch (pri)                            {                            case  red/* constant-expression */:                                printf(&quot;%-10s&quot;,&quot;red&quot;);/* code */                                break;                            case  yellow/* constant-expression */:                                printf(&quot;%-10s&quot;,&quot;yellow&quot;);/* code */                                break;                            case  blue/* constant-expression */:                                printf(&quot;%-10s&quot;,&quot;blue&quot;);/* code */                                break;                            case  white/* constant-expression */:                                printf(&quot;%-10s&quot;,&quot;white&quot;);/* code */                                break;                             case  black/* constant-expression */:                                printf(&quot;%-10s&quot;,&quot;black&quot;);/* code */                                break;                               default:                                break;                            }                        }                        printf(&quot;\n&quot;);                    }                }            }        }    }    printf(&quot;\ntotal:%5d\n&quot;,n);    return 0;}/*使用枚举常量red 和用0代表红，有什么区别，其实没啥问题。使用枚举常量比使用常数的优点是更加直观，当出错时，更易于检查错误信息。*/</code></pre><h2 id="9-7-用typedef声明新类型名"><a href="#9-7-用typedef声明新类型名" class="headerlink" title="9.7    用typedef声明新类型名"></a>9.7    用typedef声明新类型名</h2><p>用typedef给新的类型名来替代已有的类型名。(给已有类型取别名)</p><p>有两种情况：</p><ol><li><p>简单地用一个新类型名代替已有的类型名。</p><p>如：typedef int Integer;    //指定用Integer为类型名，作用与int相同</p></li><li><p>命名一个简单的类型名代替复杂的类型表示方法。</p><ul><li><p>命名一个新的类型名代表结构体类型</p><pre><code class="c">typedef struct{    int day;    int month;    int year;}Date;        //定义新类型名Date,代表上面的一个结构体类型。Date birthday;    //定义结构体类型变量，因为用typedef Date就是结构体的别名。</code></pre></li><li><p>命名一个新类型名代表数组类型</p><p>typedef int Num[100];        //声明Num为整形数组类型名</p><p>Num a;                    //定义a为整形数组名，它有100个元素</p></li><li><p>命名一个类型代表指针类型</p><p>typedef  char * String；    //声明String为字符指针类型</p><p>String p,s[10];            //定义p为字符指针变量，s为字符指针数组</p></li><li><p>命名一个新类型名代表只想函数的指针。</p><p><strong>归纳总结：声明新类型名的方法</strong></p><ol><li><p>按照定义变量方法写出定义体</p></li><li><p>将变量名换成新类型名</p></li></ol></li></ul></li><li><p>在最前面加关键字</p><ol start="4"><li>用新类型名区定义变量</li></ol><p>注意：习惯上typedef声明的类型名第一个字母大写</p></li></ol><ol><li><p>以上方法实际上是为为特定的类型指定了一个同义字。</p></li><li><p>使用typeder只是给已有类型取了一个别名，并没有创造新类型</p></li><li><p>typedef声明数组类型、指针类型、结构体类型、共用体类型、枚举类型，使得编程更加方便。</p></li><li><p>typedef与#define表面上有相似之处。</p><p>如：  typedef int Count;</p><p>​        #define Count int;</p><p>作用都是用Count代表int。</p><p>1.#define是在预编译时完成的，只能做简单的字符串替换。</p><p>2.typedef是在编译阶段处理的。并不是简单的字符串替换。例如：typedef int Num[10];Num a;并不是用Num[10]去替代int ，而是采用定义变量的方法那样先生成一类型名，然后用它去定义变量。</p></li><li><p>当不同源文件用到同一类型数据时，常用typedef声明一些数据类型。</p></li><li><p>使用typedef名称有利于程序的通用和移植。可以看书上的数据类型长度在不同编译器上不同的案例 p329。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-mhNhJsME&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;9-1-定义和使用结构体变量&quot;&gt;&lt;a href=&quot;#9-1-定义和使用结构体变量&quot; class=&quot;headerlink&quot; title=&quot;9.1    定义和使用结构体变量&quot;&gt;&lt;/a&gt;9.1    定义和使用结构体变量&lt;/h2&gt;&lt;h3 id=&quot;9-1-1-自己建立结构体类型&quot;&gt;&lt;a href=&quot;#9-1-1-自己建立结构体类型&quot; class=&quot;headerlink&quot; title=&quot;9.1.1    自己建立结构体类型&quot;&gt;&lt;/a&gt;9.1.1    自己建立结构体类型&lt;/h3&gt;&lt;p&gt;C语言允许用户自己建立由不同类型数据组成的复合型数据结构，它称为结构体。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>善于利用指针</title>
    <link href="https://www.nscblog.top/posts/659d25f6/"/>
    <id>https://www.nscblog.top/posts/659d25f6/</id>
    <published>2020-06-05T16:14:59.000Z</published>
    <updated>2020-08-23T06:12:17.605Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-UjqOBPZm" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="8-1-指针是什么"><a href="#8-1-指针是什么" class="headerlink" title="8.1    指针是什么"></a>8.1    指针是什么</h2><blockquote><p>一个变量的地址就是该变量的“指针”</p></blockquote><p>定义一个变量，系统为其分配空间 有地址指向变量空间（变量单元），地址就称为“指针”。</p><p>指针是内存空间的地址，存储单元就是所分配的内存空间。</p><p>直接访问：直接通过变量名访问。</p><p>间接访问：将变量i的地址存在另一个变量中，然后通过该变量来找到变量i的地址</p><p>指针：一个变量的地址。</p><p>指针变量：存放另一个变量的地址的变量。</p><a id="more"></a><h2 id="8-2-指针变量"><a href="#8-2-指针变量" class="headerlink" title="8.2    指针变量"></a>8.2    指针变量</h2><h3 id="8-1-1-使用指针变量的例子"><a href="#8-1-1-使用指针变量的例子" class="headerlink" title="8.1.1    使用指针变量的例子"></a>8.1.1    使用指针变量的例子</h3><blockquote><p>指针变量：存放另一个变量的地址的变量。</p></blockquote><p>例8.1    通过指针变量访问整形变量</p><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;# include &quot;math.h&quot;int main(){    int a=100,b=200;    // * pointer_a表示pointer_a所指向的变量(对象)    // pointer_a(地址) 表示指向       int * pointer_a,* pointer_b;       // 把变量a的地址指针赋值给指针变量pointer_a    pointer_a=&amp;a;    pointer_b=&amp;b;    printf(&quot;a=%d,b=%d\n&quot;,a,b);     printf(&quot;* pointer_a=%d,* pointer_b=%d\n&quot;,* pointer_a,* pointer_b);    return 0;  } </code></pre><h3 id="8-2-2-怎样定义指针变量"><a href="#8-2-2-怎样定义指针变量" class="headerlink" title="8.2.2    怎样定义指针变量"></a>8.2.2    怎样定义指针变量</h3><blockquote><p>定义指针变量一般形式：类型名 * 指针变量名；</p></blockquote><p>说明：</p><ol><li><p>指针变量前面的 * 表示该变量的类型为指针型变量</p></li><li><p>在定义指针变量时必须指定基类型。不指定基类型的话，我们不知道所指向的数据在内存中所占字节数和存放方式。</p><p>知道存放数据类型，才能按存储单元的长度以及数据的存储形式正确地取出该数据。</p><p><strong>一个变量的指针含义包括两个方面，一是以存储单元编号表示的地址，一是它指向的存储单元的数据类型。</strong></p></li><li><p>如何表示指针类型。<strong>指向整形数据的指针类型表示 int *  , 读作“指向int的指针或简称“int指针”。</strong></p></li><li><p>指针变量中只能存放地址，不要将一个整数赋给一个指针变量。如：</p><pre><code>int * pointer_1,a=100;* pointer_1=100;//这是不合法的</code></pre></li></ol><h3 id="8-2-3-怎样引用指针变量"><a href="#8-2-3-怎样引用指针变量" class="headerlink" title="8.2.3    怎样引用指针变量"></a>8.2.3    怎样引用指针变量</h3><p>在引用指针变量时，可能有3种情况：</p><ol><li>给指针变量赋值。</li><li>引用指针变量指向的变量。如：pirntf(“%d”,* p);</li><li>引用指针变量的值。</li></ol><p>注意：</p><ol><li>&amp;为取地址符。&amp;a是变量a的地址。</li><li>*为指针运算符， *p 代表指针变量p指向的对象。</li></ol><pre><code class="c">int main(){    int *p,*p1,*p2,a,b;    printf(&quot;请输入两个数字：\n&quot;);    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    if(a&lt;b)    {        p2=&amp;a;//使p2变量指向变量a        p1=&amp;b;//使p1变量指向变量b    }    printf(&quot;a=%d\tb=%d\n&quot;,a,b);    printf(&quot;max=%d\tmin=%d&quot;,* p1,* p2);//输出p1和p2所指向的变量    return 0; } </code></pre><h3 id="8-2-4-指针变量作为函数参数"><a href="#8-2-4-指针变量作为函数参数" class="headerlink" title="8.2.4    指针变量作为函数参数"></a>8.2.4    指针变量作为函数参数</h3><p>指针类型变量作为函数参数的作用：将一个变量的地址传送到另一个函数中。</p><p>例如：</p><pre><code class="c"># include &quot;stdio.h&quot;/*    对输入的两个整数按大小顺序输出。 */int main(){    void swap(int * p1,int * p2);    int a,b;    int * pointer_a,* pointer_b;    printf(&quot;请输入两个数\n&quot;);    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    pointer_a=&amp;a;    pointer_b=&amp;b;    if(a&lt;b)        swap(pointer_a,pointer_b);     printf(&quot;max=%d\tmin=%d\n&quot;,a,b);    return 0;}void swap(int * p1,int * p2){    int temp;    /*     下面交换的是变量的值，不是地址值，temp是int类型，不是int指针类型    */    temp= * p1;    * p1= * p2;    * p2= temp; } </code></pre><p>如果想通过函数调用得到n个要改变的值，可以这样做：</p><ol><li>在主调函数中设n个变量，用n个指针变量指向它们。</li><li>设计一个函数，有n个指针形参。</li><li>在主调函数中调用这个函数，在调用时将这n个指针变量作为实参，将它们的地址传给该函数的形参；</li><li>在执行该函数的过程中，通过形参指针变量，改变它们所指的n个变量的值；</li><li>在主调函数中就可以使用这些改变了值的变量。</li></ol><pre><code class="c"># include &quot;stdio.h&quot;/*    对输入的两个整数按大小顺序输出。 */int main(){    void exchange(int * p1,int * p2,int * p3);    int a,b,c;    int * pointer_a,* pointer_b,* pointer_c;    printf(&quot;请输入三个数\n&quot;);    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);    pointer_a=&amp;a;    pointer_b=&amp;b;    pointer_c=&amp;c;    exchange(pointer_a,pointer_b,pointer_c);    printf(&quot;the order is %d\t%d\t%d\n&quot;,a,b,c);    /*    C语言中实参变量和形参变量之间的数据传递是单向的“值传递”方式    用指针变量做函数参数时同样要遵循这个规则。    不能通过执行调用函数来实现改变实参指针变量的值，但是可以改变实参指针变量所指的变量的值。     */    printf(&quot;%d%d%d&quot;,* pointer_a,* pointer_b,* pointer_c);    return 0;}void exchange(int * p1,int * p2,int * p3){    void swap(int * sp1,int * sp2);    if( * p1&lt;* p2) swap(p1,p2);    if( * p1&lt;* p3) swap(p1,p3);    if( * p2&lt;* p3) swap(p2,p3);}void swap(int * sp1,int * sp2){    int temp;    temp= * sp1;    * sp1= * sp2;    * sp2= temp; } </code></pre><h2 id="8-3-通过指针引用数组"><a href="#8-3-通过指针引用数组" class="headerlink" title="8.3    通过指针引用数组"></a>8.3    通过指针引用数组</h2><h3 id="8-3-1-数组元素的指针"><a href="#8-3-1-数组元素的指针" class="headerlink" title="8.3.1    数组元素的指针"></a>8.3.1    数组元素的指针</h3><p>数组元素的指针就是数组元素的地址。</p><p>引用数组元素可以用下标法，也可以用指针法，使用指针法能使目标程序质量高。</p><p>C语言中，数组名代表数组元素中首元素的地址。因此，下面两个语句等价：</p><p>p=&amp;a[0];</p><p>p=a;</p><h3 id="8-3-2-在引用数组元素时指针的运算"><a href="#8-3-2-在引用数组元素时指针的运算" class="headerlink" title="8.3.2    在引用数组元素时指针的运算"></a>8.3.2    在引用数组元素时指针的运算</h3><p>在一定条件下，允许对指针进行加和减的算术运算。如：指针变量p指向数组元素</p><p>指针指向数组元素时，可以对指针进行一下运算：</p><ul><li>加一个整数(用+或+=)，如p+1</li><li>减一个整数(用-或-=)，如p-1</li><li>自增运算，如p++，++p</li><li>自减运算，如p–,–p</li><li>两个指针相减，如p1-p2，这个两个指针变量要指向统一数组时，才有意义</li></ul><p>分别说明：</p><ol><li>如果指针变量p已指向数组中的一个元素，则p+1指向同一个数组中的下一个元素，p-1指向统一数组中的上一个元素。加1代表的是加上一个数组元素所占的字节数。</li><li>如果p的初值为&amp;a[0] p+1等同于a+1</li><li>*(a+5)指向的是a[5]    [] 是变地址符 将a[i]按a[i+1]计算地址，然后找出地址单元中的值</li><li>如果指针变量p1和p2都指向统一数组，如执行p2-p1，再用两个地址之差除以数组元素的长度，这样就可以知道他们所知元素的相对距离。地址相加是没有意义的。</li></ol><h3 id="8-3-3-通过指针引用数组元素"><a href="#8-3-3-通过指针引用数组元素" class="headerlink" title="8.3.3    通过指针引用数组元素"></a>8.3.3    通过指针引用数组元素</h3><ol><li>下标法</li><li>指针法，如*(a+1)或者 *(p+1)</li></ol><pre><code class="c"># include &quot;stdio.h&quot;/*有一个整形数组a,要求输出数组中的全部元素。*/int main(){    int a[5];    int i;    printf(&quot;please enter 5 integer numbers:\n&quot;);    for (i=0;i&lt;5;i++)        scanf(&quot;%d&quot;,a+i);    for (i=0;i&lt;5;i++)        printf(&quot;%d\t&quot;,*(a+i));    return &#39;\0&#39;; } </code></pre><blockquote><p>注意：C语言没有像Java那样的异常检查机制。所以我们要尽量避免逻辑上的错误，如：数组下标越界的错误。</p></blockquote><p>指向数组的指针变量也可以带下标，如p[i]：对p[i]处理成*(p+i),必须知道p指向数组哪个元素的地址。</p><p>利用指针引用数组元素，比较灵活方便，有不少技巧。</p><p>​    1、p++;  *p;</p><p>p++使p指向下一元素a[1]。然后若再执行*p，则得到下一个元素a[1]的值。</p><p>​    2、*p++;</p><p>++和*同优先级，结合方向为自右向左，因此他等价于 *(p++),先引用p的值，实现 *p的运算，然后再使p自增一。</p><p>如：for(i=0;i&lt;10;i++,p++)</p><p>​            printf(“%d”,* p);</p><p>可以改写为</p><p>for(i=0;i&lt;10;i++)</p><p>​    printf(“%d”,* p++);</p><p>​    3、*(p++)和 *(++p)作用是否相同，不相同。前者是先取 *p的值，然后再使p+1后者是先使p+1 再取 *p</p><p>​    4、++(*p)。表示p所指向的元素值加1，如果p=a,那么++( *p)和++a[0]等价。</p><p>​    5、*（p–）== a[i–];    *（++p）== a[++i];    *（–p）== a[–i]</p><h3 id="8-3-4-用数组名作函数参数"><a href="#8-3-4-用数组名作函数参数" class="headerlink" title="8.3.4    用数组名作函数参数"></a>8.3.4    用数组名作函数参数</h3><p>C编译都是将形参数组名作为指针变量来处理的。</p><p>所以：void swap(int arr[],int n) 可以改写成 void swap(int * arr,int n)</p><p><img src="https://i.loli.net/2020/08/09/gVREsZKfCUp5hWI.png" alt="以变量名和数组名作为函数参数的比较.png" loading="lazy"></p><p>在函数调用进行虚实结合的方法都是采用“值传递”，它的值就是实参数组首元素的地址。函数执行期间，它可以再次被赋值。</p><pre><code class="c"># include &quot;stdio.h&quot;/*    将数组中n个整数按相反顺序存放 */int main(){    void inv(int *x,int n);    int i,a[10]={3,7,5,8,9,4,2,1,0,6};    printf(&quot;初始数组为\n&quot;);    for(i=0;i&lt;10;i++)        printf(&quot;%d\t&quot;,a[i]);    printf(&quot;\n&quot;);     inv(a,10);    printf(&quot;调换顺序后的数组是\n&quot;);    for(i=0;i&lt;10;i++)        printf(&quot;%d\t&quot;,a[i]);    printf(&quot;\n&quot;);    return 0; } void inv(int * x,int n)//*x: 传入数组首个元素地址， n:需要换几个数{    int *i,*j,temp,*p,m=(n-1)/2;    i=x;    j=x+n-1;    p=x+m;    for(;i&lt;=p;i++,j--)    {        temp=*i;        *i=*j;        *j=temp;    }} </code></pre><p>归纳分析：如果一个实参数组，要想在函数中改变次数组中的元素的值。实参和形参对应关系如下：</p><ol><li>形参和实参都用数组名</li><li>实参用数组名，形参用指针变量</li><li>实参和形参都用指针变量</li><li>实参为指针变量，形参为数组名。  实参作为指针变量，必须先指针变量指向数组常量。</li></ol><pre><code class="c"># include &quot;stdio.h&quot;/*用指针法对10个整数按由大到小排序（选择排序）.c*/int main(){    void sort(int a[],int n);    int *p,a[10],i;    p=a;    printf(&quot;请输入10个不相同的数\n&quot;);     for(i=0;i&lt;10;i++)        scanf(&quot;%d&quot;,p++);    p=a;    sort(p,10);    for(i=0;i&lt;10;i++)        printf(&quot;%d\t&quot;,* p++);    return 0;}void sort(int a[],int n){    int i,temp,j;    for(i=0;i&lt;n-1;i++)        for(j=i+1;j&lt;n;j++)        {            if(a[i]&lt;a[j])            {                temp=a[i];                a[i]=a[j];                a[j]=temp;            }        }}</code></pre><h3 id="8-3-5-通过指针引用多维数组"><a href="#8-3-5-通过指针引用多维数组" class="headerlink" title="8.3.5    通过指针引用多维数组"></a>8.3.5    通过指针引用多维数组</h3><h4 id="1-多维数组元素的地址"><a href="#1-多维数组元素的地址" class="headerlink" title="1.多维数组元素的地址"></a>1.多维数组元素的地址</h4><p>C语言中，数组名代表数组元素中首元素的地址。</p><p>a[0] 代表以为数组a[0]中第0列元素地址，即&amp;a [0] [0]</p><p>a[1]代表&amp;a[1] [0]</p><p>所以a[0] [1]==a[0]+1(求取地址)</p><p><strong>二维数组指针以及指针运算规律</strong></p><p><img src="https://i.loli.net/2020/08/09/JtLZ3amgheIlPyY.png" alt="二维数组指针以及指针运算规律.png" loading="lazy"></p><p>二维数组a的有关指针</p><p><img src="https://i.loli.net/2020/08/09/LEDx7R3CklwMUh4.png" alt="二维数组a的有关指针.png" loading="lazy"></p><p><strong>二维数组名指向行，一维数组名指向列。</strong></p><p><strong>在指向行的指针前面加一个*, 就转换为指针指向列的指针。</strong></p><p>如：a 都是指向行的 加个 * ，就是a[0] [0]就列首地址</p><p>在指向列的指针前面加&amp;，就成为指向行的指针。</p><h4 id="2-指向多维数组元素的指针变量"><a href="#2-指向多维数组元素的指针变量" class="headerlink" title="2.指向多维数组元素的指针变量"></a>2.指向多维数组元素的指针变量</h4><h5 id="指向数组元素的指针变量"><a href="#指向数组元素的指针变量" class="headerlink" title="指向数组元素的指针变量"></a>指向数组元素的指针变量</h5><pre><code class="c"># include &quot;stdio.h&quot;/*遍历数组元素*/int main(){    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};    int *p;    for(p=a[0];p&lt;a[0]+12;p++)    {        if((p-a[0])%4==0)            printf(&quot;\n&quot;);        printf(&quot;%d\t&quot;,*p);     }      return 0; } </code></pre><h4 id="指向由m个元素组成的一维数组的指针变量"><a href="#指向由m个元素组成的一维数组的指针变量" class="headerlink" title="指向由m个元素组成的一维数组的指针变量"></a>指向由m个元素组成的一维数组的指针变量</h4><pre><code class="c"># include &quot;stdio.h&quot;/*输出任意一行任意一列的元素的值 */int main (){    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};    /*    int (* p)[4]    表示(* p)有4个元素，每个元素为整形。    相当于p所指的对象是有4 个整形元素的数组     p的类型不是 int* 而是int (*)[4] p被定义为指向一维数组的指针变量    */    int (* p)[4],i,j;    p=&amp;a;//这里不能写成p=a,这样表示p=a[0]     printf(&quot;请输入要输出的数的坐标(行和列)\n&quot;);    scanf(&quot;%d%d&quot;,&amp;i,&amp;j);    printf(&quot;a[%d][%d]=%d&quot;,i,j, * ( *(p+i)+j));     return 0;}</code></pre><h4 id="用指向数组的指针作为函数参数"><a href="#用指向数组的指针作为函数参数" class="headerlink" title="用指向数组的指针作为函数参数"></a>用指向数组的指针作为函数参数</h4><p>用指针变量作形参，来接受实参数组名传递来的地址。可以有两种方法：</p><ol><li>用指向变量的指针变量</li><li>用指向一维数组的指针变量</li></ol><pre><code class="c"># include &quot;stdio.h&quot;/*计算总平均分数以及第n个学生的成绩*/int main (){    void average(float *p,int n);    void search(float (* p)[4],int n);    float score[3][4]={{65,70,67,60},{80,87,90,81},{90,99,100,98}};    average( * score,12);    search(score,2);    return 0;}void average(float *p,int n)//*p 指的是二维数组0,0的坐标地址 {    float * p_end,sum=0,aver;    p_end=p+n-1;    for(;p&lt;p_end;p++)        sum+= * p;    aver=sum/n;    printf(&quot;average=%.5f\n&quot;,aver);}/*    此时p只能指向一个包含4个元素的一维数组，不能指向一维数组中的某一元素。    p的值就是 该一维数组的起始位置。     score+i == p+i*/void search(float (* p)[4],int n){    int i;    printf(&quot;the score of No.%d are :\n&quot;,n);    for(i=0;i&lt;4;i++)        printf(&quot;%5.2f\t&quot;,*(*(p+n)+i));    printf(&quot;\n&quot;);}</code></pre><h2 id="8-4-通过指针引用字符串"><a href="#8-4-通过指针引用字符串" class="headerlink" title="8.4    通过指针引用字符串"></a>8.4    通过指针引用字符串</h2><p>使用字符串的更加灵活方便的方法——通过指针引用字符串。</p><h3 id="8-4-1-字符串的引用方式"><a href="#8-4-1-字符串的引用方式" class="headerlink" title="8.4.1    字符串的引用方式"></a>8.4.1    字符串的引用方式</h3><p>在C程序中，字符串是存放在字符数组中的。引用字符串可以有两种方法：</p><ol><li><p>用数组存放一个字符串，可以通过数组名和下标引用字符串中一个字符，可以通过数组名和格式声明”%s”输出该字符串。</p></li><li><p>用字符指针变量指向一个字符串常量，通过字符指针变量引用字符串常量。</p><p>例如：</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    /*    对字符指针变量p的初始化，     实际上是把字符串第一个元素地址赋值给指针变量    */    char * p=&quot;I love China.&quot;;    /*    %s是输出字符串所用的格式字符，在输出项中给出字符指针变量名p    系统会输出p所指向字符串第一个字符，然后自动使p加1，使之指向下一个字符     输出该字符，直到遇到字符串结束标志&#39;\0&#39;为止     */    printf(&quot;%s\n&quot;,p);    return 0; } </code></pre></li></ol><p><strong>在C语言中只有字符变量，没有字符串变量</strong> </p><h3 id="8-4-2-字符指针作函数参数"><a href="#8-4-2-字符指针作函数参数" class="headerlink" title="8.4.2    字符指针作函数参数"></a>8.4.2    字符指针作函数参数</h3><blockquote><p>如果想把一个字符串从一个函数“传递”到另一个函数，可以地址传递的方法。在被调用函数中可以改变字符换的内容，在主调函数中可以引用改变后的字符串。</p></blockquote><p>例题8.20    用函数调用实现字符串的复制</p><p>1、用字符数组名作为函数参数</p><pre><code class="c"># include&lt;stdio.h&gt;int main (){    void cope_string(char form[],char to[]);    char a[]=&quot;I am a teacher.&quot;;    char b[]=&quot;You are a student.&quot;;    printf(&quot;string a is %s\nstring b is %s\n&quot;,a,b);    copy_string(a,b);    printf(&quot;string a is %s\nstring b is %s\n&quot;,a,b);    return 0;}void copy_string(char form[],char to[]){    int i=0;    for(;form[i]!=&#39;\0&#39;;i++)    {    to[i]=form[i];    }    to[i]=&#39;\0&#39;;}</code></pre><p>2、用字符型指针变量作实参</p><pre><code class="c"># include&lt;stdio.h&gt;int main (){    void cope_string(char form[],char to[]);    char a[]=&quot;I am a teacher.&quot;;    char b[]=&quot;You are a student.&quot;;    char *p1,*p2;    printf(&quot;string a is %s\nstring b is %s\n&quot;,a,b);    p1=a;p2=b;    copy_string(p1,p2);    printf(&quot;string a is %s\nstring b is %s\n&quot;,a,b);    return 0;}void copy_string(char form[],char to[]){    int i=0;    for(;form[i]!=&#39;\0&#39;;i++)    {    to[i]=form[i];    }    to[i]=&#39;\0&#39;;}</code></pre><p>3、用字符型指针变量作形参和实参</p><pre><code class="c"># include&lt;stdio.h&gt;int main (){    void cope_string(char *form,char *to);    char *a=&quot;I am a teacher.&quot;;    char b[]=&quot;You are a student.&quot;;    char *p1,*p2;    printf(&quot;string a is %s\nstring b is %s\n&quot;,a,b);    p2=b;    copy_string(a,p2);    printf(&quot;string a is %s\nstring b is %s\n&quot;,a,b);    return 0;}void copy_string(char *form,char *to){    char temp;    for(;*form!=&#39;\0&#39;;form++,to++)    {        *to=*form;    }    *to=&#39;\0&#39;;}</code></pre><p><strong>注意使用%s时不会输出’\0’，而使用%c时可以输出’\0’</strong></p><p>PDF282页上有程序优化，自己去看</p><h3 id="8-4-3-使用字符指针变量和字符数组的比较"><a href="#8-4-3-使用字符指针变量和字符数组的比较" class="headerlink" title="8.4.3    使用字符指针变量和字符数组的比较"></a>8.4.3    使用字符指针变量和字符数组的比较</h3><p>字符数组和字符指针都能实现字符串的存储和运算</p><p>但二者有区别，主要有：</p><ol><li><p>字符数组由若干个元素组成，每个元素中放一个字符，字符指针变量中存放的是地址，存的不是字符串。</p></li><li><p>赋值方式。可以对字符指针变量赋值，但不能对数组名赋值。</p><p>如：</p><pre><code class="c">char *a;a=&quot;I love China!&quot;;            //量字符串元素地址赋值给指针变量，合法。但赋值                            //给a的不是字符串，而是字符串第一个元素的地址。</code></pre><pre><code class="c">char str[14];str[0]=&#39;I&#39;;str=&quot;I love China!&quot;;        //数组名是地址，是常量，不能被赋值。</code></pre></li><li><p>初始化的含义。</p><p>对字符指针变量赋初始值，赋予第一个元素的地址</p><p>定义字符数组，并把字符串赋值给各个元素</p></li><li><p>存储单元的内容</p><p>数组是若干个存储单元，存着各元素的值。</p><p>字符指针变量，只分配一个存储单元(Visual C++为指针变量分配4个字符)。</p><blockquote><p>注意：指针必须先赋值（指定指针指向），在使用。</p></blockquote></li><li><p>指针变量的值是可以改变的，数组名代表一个固定的值，不能改变。</p></li><li><p>字符数组中各个元素的值是可以改变的（可以对它们再赋值），但字符指针变量指向的字符串常量中的内容是不可以改变的。</p><p><a href="http://www.360doc.com/content/15/1022/16/26795867_507585396.shtml" target="_blank" rel="noopener">指向字符串的指针为何不能用来修改此字符串(c语言)</a></p></li><li><p>引用数组元素。都可以用下标，都可以用指针 ，使用指针之前，确保指针指向相同数组</p></li><li><pre><code class="c">char *format;format=&quot;a=%d,b=%d\n&quot;;printf(foramt,a,b);        //因此只要改变指针变量所指的字符串，就可以该变输入输出的格式，这种printf函数称为可变格式输出函数。</code></pre><p>使用字符数组时，只能采用在定义数组时初始化或逐个对元素赋值的方法。</p></li></ol><h2 id="8-5-指向函数的指针"><a href="#8-5-指向函数的指针" class="headerlink" title="8.5     指向函数的指针"></a>8.5     指向函数的指针</h2><h3 id="8-5-1-什么是函数指针"><a href="#8-5-1-什么是函数指针" class="headerlink" title="8.5.1    什么是函数指针"></a>8.5.1    什么是函数指针</h3><p>定义了一个函数，在编译时，编译系统为函数代码分配了一段存储空间，这段存储空间的起始地址(又称入口地址)，称为这个函数的指针。</p><p>int (*p)(int,int); </p><p>说明：</p><ol><li>这表示定义一个指向函数的指针变量，用来存放某一函数的起始地址，这意味着此指针变量指向该函数。</li><li>p的类型用int(*)(int,int)表示</li></ol><h3 id="8-5-2-用函数指针变量调用函数"><a href="#8-5-2-用函数指针变量调用函数" class="headerlink" title="8.5.2    用函数指针变量调用函数"></a>8.5.2    用函数指针变量调用函数</h3><p>调用函数：</p><p> 1.通过函数名调用；</p><p> 2.通过指向函数的指针变量调用该函数</p><p>例题8.22用函数求整数a和b中的大者</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    int (*p)(int,int);    int max(int a,int b);    p=max;                 //将函数指针变量指向max函数 ，将max函数的入口地址赋值给了p    int a=5,b=6,c;    c=(*p)(a,b);    printf(&quot;%d&quot;,c);    return 0; } int max(int a,int b){    return a&gt;b?a:b;}</code></pre><blockquote><p>注意：</p><ol><li><p>int (*p)(int,int);</p><p>(*p):两侧括号不能省略，表示p先与 *结合 ，是指针变量，再与后面的()结合，()表示的是函数。表明这个指向变量指向的是函数。</p></li><li><p>如果写成：int *p(int,int);</p><p>这样相当于 int *(p(int,int)); 就成了声明一个p函数，这个函数的返回值是指向整形变量的指针。(主要是因为（）的优先级高于 *)</p></li></ol></blockquote><h3 id="8-5-3-怎样定义和使用指向函数的指针变量"><a href="#8-5-3-怎样定义和使用指向函数的指针变量" class="headerlink" title="8.5.3    怎样定义和使用指向函数的指针变量"></a>8.5.3    怎样定义和使用指向函数的指针变量</h3><p>一般形式：</p><blockquote><p>类型名 (* 指针变量名) (函数参数列表)；</p></blockquote><p>说明：</p><p>1.定义指向函数的指针变量，只能指向规定的返回类型，且参数列表相同的函数。</p><p>2.如果要用指针调用函数，必须先使指针变量指向该函数。（<strong>指针变量先赋值再使用</strong>）</p><p>3.再给函数指针变量赋值时，只须给出函数名而不必给出参数</p><p>4.用函数指针变量调用函数时，直接用（*p）代替函数名，后面（）填写相应的实参。</p><p>5.对指向函数的指针变量不能进行算术运算。进行加减是没有实际意义的</p><p>6.用函数名调用函数，只能调用一个，通过指针调用函数比较灵活，可以根据不同情况进行调用。</p><p>例题：输入两个数，让用户选择输出最大最小的数。</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    int (*p)(int,int);    int max(int a,int b);    int min(int a,int b);    p=max;                 //将函数指针变量指向max函数     int a=5,b=6,c,n;    printf(&quot;pleanse chose one or two:\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    if(n==1)p=max;        //输入的是1的话则使指针指向max     if(n==2)p=min;        //输入的是2的话则使指针指向min    c=(*p)(a,b);    printf(&quot;%d&quot;,c);    return 0; } int max(int a,int b){    return a&gt;b?a:b;}int min(int a,int b){    return a&gt;b?b:a;}</code></pre><h3 id="8-5-4-用指向函数的指针做函数参数"><a href="#8-5-4-用指向函数的指针做函数参数" class="headerlink" title="8.5.4    用指向函数的指针做函数参数"></a>8.5.4    用指向函数的指针做函数参数</h3><p>例如：</p><pre><code class="c">void fun(int (*p)(int),int (*p2)(int,int))//定义函数，参数两个函数指针变量{                                          //将两个函数名传递给函数指针变量    int a,b,i=3,j=5;    a=(*p)(i);                              //调用f1函数，i是参数    b=(*p2)(i,j);                          //调用f2函数，i,j是参数}</code></pre><p>函数只有被调用时，才分配存储单元。</p><p>使用函数指针变量，可以简化程序的编写，减少冗余代码，</p><p>通过一个例子来展示指针函数参数的应用</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    int (*p)(int,int);    int max(int a,int b);    int min(int a,int b);    int add(int a,int b);    int fun(int a,int b,int (*p)(int,int));    int a=5,b=6,c,n;    printf(&quot;pleanse chose one , two or three:\n&quot;);    scanf(&quot;%d&quot;,&amp;n);    if(n==1)p=max;        //输入的是1的话则使指针指向max     if(n==2)p=min;        //输入的是2的话则使指针指向min    if(n==3)p=add;        //输入的是3的话则使指针指向add     fun (a,b,p);            printf(&quot;%d&quot;,c);    return 0; } void fun(int a,int b,int (*p)(int,int)){    printf(&quot;%d&quot;,(* p)(a,b));}int max(int a,int b){    return a&gt;b?a:b;}int min(int a,int b){    return a&gt;b?b:a;}int add(int a,int b){    return a+b;}</code></pre><h2 id="8-6-返回指针值的函数"><a href="#8-6-返回指针值的函数" class="headerlink" title="8.6    返回指针值的函数"></a>8.6    返回指针值的函数</h2><p>int *a (int x,int y);</p><p>在a的两侧分别为* 和 () 而()的优先级要比*的高，所以a先与()结合，显然这是函数的形式。</p><p>函数前有*， 表是这是一个指针型函数。</p><p>定义返回指针值的函数的一般形式：</p><p>类型名 * 函数名(参数列表)；</p><p>例题：</p><pre><code class="c"># include &lt;stdio.h&gt; int main(){    float score[][4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}};    float * search(float (*p)[4],int n);    float * res;    int i,k;    printf(&quot;enter the number of student:\n&quot;);    scanf(&quot;%d&quot;,&amp;k);    printf(&quot;the score of No.%d are:\n&quot;,k);    res=search(score,k);    for(i=0;i&lt;4;i++,res++)        printf(&quot;%.2f\t&quot;,* res);    printf(&quot;\n&quot;);    return 0;}float * search(float (* p)[4],int n){    float *pt;    pt = * (p+n);  //pt的值是&amp;score[k][0]     return pt;} </code></pre><pre><code class="c"># include &lt;stdio.h&gt; /*找出成绩不及格的学号以及输出学生的分数*/int main(){    float score[][4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}};    float * search(float (*p)[4]);    float * res;    int j,i;    for(j=0;j&lt;3;j++)    {        res=search(score+j);        if(res==*(score+j))        for(i=0;i&lt;4;i++,res++)            printf(&quot;%.2f\t&quot;,* res);        printf(&quot;\n&quot;);    }    return 0;}float * search(float (* p)[4]){    float *pt;    int i;    pt=NULL;    for(i=0;i&lt;4;i++)        if(*(*p+i)&lt;60)            pt = * p;  //成绩不合格的，pt的值是&amp;score[k][0]     return pt;} </code></pre><h2 id="8-7-指针数组和多重指针"><a href="#8-7-指针数组和多重指针" class="headerlink" title="8.7    指针数组和多重指针"></a>8.7    指针数组和多重指针</h2><h3 id="8-7-1-什么是指针数组"><a href="#8-7-1-什么是指针数组" class="headerlink" title="8.7.1 什么是指针数组"></a>8.7.1 什么是指针数组</h3><p>一个数组，所有元素都是指针类型数据，称为指针数组。如：int  *p[3];</p><p>优先级：()&gt;[]&gt;*</p><p>先与优先级高者结合，然后在与优先级低者结合。</p><p>int (*p)[4];            //这是指向一维数组的指针变量</p><p>指针数组比较适合用来指向若干个字符串，使字符串更加方便灵活。</p><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;string.h&gt;/*数组指针的简单使用*/int main(){    void swap_string(char *str[],int n);    void print_str(char *str[],int n);    char *str[]={&quot;Follow me&quot;,&quot;BASIC&quot;,&quot;Great Wall&quot;,&quot;FORTRAN&quot;,&quot;Computer Design&quot;};    int n=5;    swap_string(str,n);    print_str(str,n);    return 0;} void swap_string(char *str[],int n){     char *temp;     int i,k,j;     for(i=0;i&lt;n-1;i++)     {         for(j=i+1;j&lt;n;j++)         {             if(strcmp(str[i],str[j])&gt;0)             {                 temp=str[i];                 str[i]=str[j];                 str[j]=temp;             }         }      } } void print_str(char *str[],int n){    int i=0;    while(i&lt;n)    {        printf(&quot;%s\n&quot;,str[i]);//按指针数组元素的顺序输出它们所指向的字符串         i++;     }}</code></pre><h3 id="8-7-2-指向指针数据的指针"><a href="#8-7-2-指向指针数据的指针" class="headerlink" title="8.7.2    指向指针数据的指针"></a>8.7.2    指向指针数据的指针</h3><p>char * str[]={“Follow me”,”BASIC”}</p><p>char *p;</p><p>p=str[1];</p><p>p就是指向指针型数据的指针变量</p><p>定义一个指向指针数据的指针变量：char **p;</p><p><em>的结合性是从右到左 char *</em>p 等同于 char *( *p);</p><p>(*p)表示这是一个指针变量，char * 表示p 指向的是一个字符型指针变量</p><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;/*    使用指向指针数据的指针变量 */int main(){    char * str[]={&quot;Follow me&quot;,&quot;BASIC&quot;,&quot;Great Wall&quot;};    char **p;    int i;    for(i=0;i&lt;3;i++)    {        p=str+i;        printf(&quot;%s\n&quot;,*p);     }     return 0;}</code></pre><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;string.h&quot;/*    指针元素指向实型数据或整形数据。 */int main(){    int a[]={1,3,5,7,9};    int * b[]={&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4]};      int **p;    int i;    for(i=0;i&lt;5;i++)    {        p=b+i;        printf(&quot;%d\n&quot;,*p); //*p是b[i]的地址，**p是a[i]的值     }     return 0;}</code></pre><p>如果在一个指针变量中存放一个目标变量的地址，这就是“单级间址”。指向指针数据的指针用的是“二级间址”方法。</p><p><img src="https://i.loli.net/2020/08/08/AcHrVilOhkG5qCM.png" alt="多重指针.png" loading="lazy"></p><h3 id="8-7-3-指针数组作main函数的形参"><a href="#8-7-3-指针数组作main函数的形参" class="headerlink" title="8.7.3    指针数组作main函数的形参"></a>8.7.3    指针数组作main函数的形参</h3><pre><code class="c">/*argc :参数的个数argv :命令行参数          命令行一般形式: file China Bejing          命令名与个参数之间用空格分隔          file也算一个参数          命令行参数都是字符串main函数有操作系统调用*/int main(int argc,char * argv[]){}</code></pre><h2 id="8-8-动态内存分配与指向它的指针变量"><a href="#8-8-动态内存分配与指向它的指针变量" class="headerlink" title="8.8    动态内存分配与指向它的指针变量"></a>8.8    动态内存分配与指向它的指针变量</h2><h3 id="8-8-1-什么是内存的动态分配"><a href="#8-8-1-什么是内存的动态分配" class="headerlink" title="8.8.1    什么是内存的动态分配"></a>8.8.1    什么是内存的动态分配</h3><p>动态存储区被称为栈</p><p>建立内存动态分配区域，以存放一些临时用的数据。这块区域被称为堆。</p><p>临时数据不必在程序中定义声明，无需关心其声明存在期。需要时随时开辟，不需要时随时释放。</p><p>由于未在声明部分定义他们为变量或数组，因此只能通过指针来引用。不能通过变量或数组引用。</p><h3 id="8-8-2-怎样建立内存的动态分配"><a href="#8-8-2-怎样建立内存的动态分配" class="headerlink" title="8.8.2    怎样建立内存的动态分配"></a>8.8.2    怎样建立内存的动态分配</h3><p>内存的动态分配是通过系统提供的<strong>库函数</strong>实现的：</p><ol><li><p>malloc</p><p>其函数原型：</p><p><strong>void * malloc (unsigned int size);</strong></p><p>作用：在动态存储区分配一个长度为size的连续空间</p><p>返回值是所分配区域的第一个字节地址。</p><blockquote><p>注意：</p><p>指针的基类型是void ，即不指向任何类型的数据，只提供一个地址。</p><p>如果函数没有成功执行（内存空间不足），则返回空指针</p></blockquote></li><li><p>calloc</p><p>函数原型：</p><p><strong>void * calloc(unsigned n,unsigned sized);</strong></p><p>作用：在内存的动态存储区中分配n个长度为size的连续空间</p><p>用calloc函数可以为一维数组开辟动态存储空间，n为元素个数，每个元素长度为size。这就是动态数组。</p><p>函数返回指向所分配域的起始位置的指针；分配不成功，返回null</p></li><li><p>free</p><p>函数原型：</p><p><strong>void free(void * p);</strong></p><p>作用：是释放指针变量p所指向的动态空间，使这部分空间能被其他变量使用。p应是最近一次调用calloc或malloc函数时得到的函数返回值。</p></li><li><p>realloc</p><p>函数原型：</p><p><strong>void * realloc (void *p,unsigned size);</strong></p><p>作用： 修改已经通过malloc函数或calloc函数获得了动态空间</p><p>返回值p不变，重新分配不成功返回NULL</p></li></ol><p>以上4个函数的声明在stdlib.h头文件中</p><p>C99标准以前，malloc，calloc,realloc函数的基类型为char，c99把这些函数的基类型定义为void，这种指针称为无类型指针。仅提供一个存地址，而不指向具体对象。</p><h3 id="8-3-3-void-指针类型"><a href="#8-3-3-void-指针类型" class="headerlink" title="8.3.3    void 指针类型"></a>8.3.3    void 指针类型</h3><p><strong>C99允许使用基类型为void的指针空类型。</strong></p><p>void类型应理解为空类型或不指向确定的类型，不应理解指向任何类型的数据</p><pre><code class="c">int a=3;int *p1=&amp;a;char * p2;void * p3;p3=(void *)p1;p2=(char *)p3;</code></pre><blockquote><p>当void指针赋值给不同积累性的指针变量（相反）时，编译系统会自动进行转换，不必用户自己进行强制转换。</p><p>赋值后p3得到a的地址，但不指向a，不能通过*p3输出a的值。    </p></blockquote><pre><code class="c"># include &quot;stdio.h&quot;# include &quot;stdlib.h&quot;/*    了解动态内存分配和void指针的使用     内存的动态分配主要应用于简历程序中的动态数据结构(如：链表) */int main(){    void check(int *);    int *p1,i;    /*    sizeof运算符测定不同系统中存放的一个整数的字节数。    p1是空类型不确定指向，所以要进行强转 表明指向整形数据     */    p1=(int *)malloc(5*sizeof(int));    for(i=0;i&lt;5;i++)    {        *(p1+i)=i+1;    }    check(p1);    free(p1);    return 0;} void check(int *p){    int i=0;    for(;i&lt;5;i++)    {        if(p[i]&lt;60)            printf(&quot;%d&quot;,p[i]);     }     printf(&quot;\n&quot;); } </code></pre><h3 id="8-9-有关指针的小结"><a href="#8-9-有关指针的小结" class="headerlink" title="8.9    有关指针的小结"></a>8.9    有关指针的小结</h3><p>简单小结：</p><ol><li><p>指针的含义，指针就是地址</p><p>指针是地址本身，指针变量是用来存放地址的变量</p><p>类型名表示的是指针指向的数据类型，而不是    指针是类型名。</p></li><li><p>什么叫“指向”？地址就意味着指向，因为通过地址能找到该地址的对象</p><p>void * 指针是一种特殊的指针，不指向任何的数据，如果需要用地址指向某类型的数据，应先对地址进行类型转换。</p></li><li><p>要深入掌握在对数组的操作中正确地使用指针，搞清楚指针的指向</p></li><li><p>指针变量的归纳比较：</p><p><img src="https://i.loli.net/2020/08/08/5oyQFL6DAKVzhZ2.png" alt="指针变量的比较归纳1.png" loading="lazy"></p><p><img src="https://i.loli.net/2020/08/08/F8JYLBtlEQqkhiv.png" alt="指针变量的比较归纳2.png" loading="lazy"></p></li><li><p>指针运算</p><ol><li>指针变量加（减）一个整数</li><li>指针变量赋值（赋值的是地址）</li><li>两个指针变量可以相减（指向同一数组）</li><li>两个指针变量比较（指向同一个数组，可以元素的相对位置）</li></ol></li><li><p>指针变量可以有NULL（空值），表示该指针变量不指向任何变量。</p><p>NULL  在stdio.h预编译处理  # define NULL 0</p></li></ol><p>指针的优点：</p><ol><li>提高程序效率</li><li>在调用函数时当指针指向的变量值改变时，这些值能够为主调函数使用，即可以从函数调用中得到多个可改变的值。</li><li>可以实现动态内存分配。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-UjqOBPZm&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;8-1-指针是什么&quot;&gt;&lt;a href=&quot;#8-1-指针是什么&quot; class=&quot;headerlink&quot; title=&quot;8.1    指针是什么&quot;&gt;&lt;/a&gt;8.1    指针是什么&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个变量的地址就是该变量的“指针”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义一个变量，系统为其分配空间 有地址指向变量空间（变量单元），地址就称为“指针”。&lt;/p&gt;
&lt;p&gt;指针是内存空间的地址，存储单元就是所分配的内存空间。&lt;/p&gt;
&lt;p&gt;直接访问：直接通过变量名访问。&lt;/p&gt;
&lt;p&gt;间接访问：将变量i的地址存在另一个变量中，然后通过该变量来找到变量i的地址&lt;/p&gt;
&lt;p&gt;指针：一个变量的地址。&lt;/p&gt;
&lt;p&gt;指针变量：存放另一个变量的地址的变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>用函数实现模块化程序设计</title>
    <link href="https://www.nscblog.top/posts/e1d8c1a1/"/>
    <id>https://www.nscblog.top/posts/e1d8c1a1/</id>
    <published>2020-05-30T12:43:07.000Z</published>
    <updated>2020-08-23T06:13:32.176Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-ckDLXTEH" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="7-1为什么要用函数"><a href="#7-1为什么要用函数" class="headerlink" title="7.1为什么要用函数"></a>7.1为什么要用函数</h2><blockquote><p>函数就是功能，每个函数用来实现一个特定的功能。</p></blockquote><p>在程序设计中要善于利用函数，来减少重复编写程序段的工作量实现模块化设计。</p><p>一个C程序可以由一个主函数和若干个其他函数构成</p><a id="more"></a><p>例7.1</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    //声明print_star函数   告知编译器函数的相关信息 参数类型和数量  返回值类型       void print_star();    //声明print_message函数    void print_message();     //调用print_star函数    print_star();    //调用print_message函数    print_message();     //调用print_star函数    print_star();    return &#39;\0&#39;; }  //定义print_star函数void print_star(){    printf(&quot;**********************\n&quot;); }//定义一个print_message函数void print_message(){    printf(&quot;Hello World!!\n&quot;);  }  </code></pre><p>说明：</p><ol><li>一个C程序由一个或多个程序模块组成，每个程序模块作为一个源程序文件。</li><li>一个源程序文件由一个或多个函数以及其他有关内容组成。一个源程序文件是一个编译单位。</li><li>C程序执行是从main函数开始的。在main函数中结束整个程序的运行。</li><li>所有函数都是平行的，定义函数时是分别进行，相互独立的。</li><li>从用户使用的角度看，函数有两种。<ul><li>库函数，由编译系统提供，不用自己定义，可以直接使用。</li><li>用户自定义函数。用于解决用户撰文需要的函数。</li></ul></li><li>从函数形式上看，函数分两类。<ul><li>无参函数。</li><li>有参函数。</li></ul></li></ol><h2 id="7-2-怎样定义函数"><a href="#7-2-怎样定义函数" class="headerlink" title="7.2    怎样定义函数"></a>7.2    怎样定义函数</h2><blockquote><p>C语言要求，在程序中用到的所有函数，必须“先定义，后使用”。</p></blockquote><p>定义函数应包括以下几个内容：</p><ol><li>函数名</li><li>函数返回值类型</li><li>函数参数名和类型，无参函数不需要这项</li><li>指定函数应当完成什么操作，函数的功能</li></ol><h3 id="7-2-2-定义函数的方法"><a href="#7-2-2-定义函数的方法" class="headerlink" title="7.2.2    定义函数的方法"></a>7.2.2    定义函数的方法</h3><p><strong>定义无参函数</strong></p><p>一般形式：</p><pre><code class="c">类型名    函数名(){    函数体}或类型名    函数名(void){    函数体}</code></pre><blockquote><p>注意：</p><p>函数体包括<strong>声明部分</strong>和<strong>语句部分</strong></p><p>声明部分，如：int x;</p><p>语句部分，如：printf(“%d”,x);</p></blockquote><p><strong>定义有参函数</strong></p><pre><code class="c">类型名 函数名(){    函数体}</code></pre><p><strong>定义空函数</strong></p><pre><code class="c">类型名    函数名(){}</code></pre><blockquote><p>空函数用于扩充新功能</p></blockquote><h2 id="7-3-调用函数"><a href="#7-3-调用函数" class="headerlink" title="7.3    调用函数"></a>7.3    调用函数</h2><h3 id="7-3-1-函数调用形式"><a href="#7-3-1-函数调用形式" class="headerlink" title="7.3.1    函数调用形式"></a>7.3.1    函数调用形式</h3><p>按函数调用在程序中出现的形式和位置来分，可以有一下3种调用方式。</p><p><strong>1.函数调用语句</strong></p><p>把函数调用作为单独的语句</p><p><strong>2.函数表达式</strong></p><p>函数调用出现在另一个表达式中</p><p><strong>3.函数参数</strong></p><p>函数调用作为另一个函数的参数</p><h3 id="7-3-2-函数调用时数据传递"><a href="#7-3-2-函数调用时数据传递" class="headerlink" title="7.3.2    函数调用时数据传递"></a>7.3.2    函数调用时数据传递</h3><blockquote><p><strong>形式参数</strong></p></blockquote><p>定义函数时的变量名</p><blockquote><p><strong>实际参数</strong></p></blockquote><p>调用时传递的常量，变量或表达式。</p><blockquote><p><strong>实参和形参间的数据传递</strong></p></blockquote><p>形参从实参那获取值。</p><h3 id="7-3-3-函数调用的过程"><a href="#7-3-3-函数调用的过程" class="headerlink" title="7.3.3    函数调用的过程"></a>7.3.3    函数调用的过程</h3><ol><li>发生函数调用时，函数的形参被临时分配内存单元</li><li>将实参对应的值传递给形参</li><li>执行被调用函数的语句</li><li>通过return语句将函数值带回主调函数（如果函数不需要返回值，则不需要return语句，函数定义类型应定义为void类型）</li><li>调用结束，形参单元被释放。实参没有改变</li></ol><h3 id="7-3-4-函数的返回值"><a href="#7-3-4-函数的返回值" class="headerlink" title="7.3.4    函数的返回值"></a>7.3.4    函数的返回值</h3><blockquote><p>函数的返回值：函数调用使主调函数能得到一个确定的值。</p></blockquote><p>说明(对于函数返回值)：</p><ol><li>函数的返回值是通过函数中的return语句获得的。</li><li>定义函数时指定函数返回值类型。</li><li>在定义函数时指定函数类型一般和return语句中的表达式类型一致。函数类型决定返回值的类型。数值类型会自动进行类型转换。</li><li>没有返回值的函数，定义为void类型</li></ol><h2 id="7-4-对被调用函数的声明和函数原型"><a href="#7-4-对被调用函数的声明和函数原型" class="headerlink" title="7.4    对被调用函数的声明和函数原型"></a>7.4    对被调用函数的声明和函数原型</h2><p>函数调用所需条件</p><ol><li>已经被定义好的函数</li><li>使用库函数，使用预编译指令（#include）将有关库函数时所需用到的信息“包含”到本文件中来。</li><li>使用自定义函数，在主调函数中对被调用函数进行声明。（声明是为了正确识别和检查被调用的函数[包括信息有：函数名，返回值类型，参数数量，顺序，类型]是否合法）</li></ol><p>函数原型（函数声明）有两种：</p><ol><li>函数类型 函数名（参数类型1 参数名1，参数类型2 参数2）；</li><li>函数类型 函数名（参数类型1，参数类型2）；</li></ol><h2 id="7-5-函数的嵌套调用"><a href="#7-5-函数的嵌套调用" class="headerlink" title="7.5    函数的嵌套调用"></a>7.5    函数的嵌套调用</h2><p>一张图就解释清楚了</p><p><img src="https://i.loli.net/2020/06/11/BHdYyS6whuM9nZi.png" alt="函数的嵌套调用.png" loading="lazy"></p><h2 id="7-6-函数的递归调用"><a href="#7-6-函数的递归调用" class="headerlink" title="7.6    函数的递归调用"></a>7.6    函数的递归调用</h2><p>在调用一个函数的过程有出现直接或间接的调用该函数本身，称为函数的递归调用。</p><p>例如：</p><pre><code class="c"># include &quot;stdio.h&quot;int main() {    int num=5;    //声明函数    int age(int num);    printf(&quot;%d&quot;,age(num));//在输出函数里调用函数     return 0; }//定义函数int age(int num){    int c;    if(num==1)        c=10;    else        c=age(num-1)+2;     return c;}</code></pre><p>如果要求递归过程不是无限制进行下去，必须具有一个结束递归过程的条件。</p><pre><code class="c"># include &quot;stdio.h&quot;/*使用递归求阶乘 */ int main() {    int num=10;    //声明函数    int factorial(int num);    printf(&quot;%d&quot;,factorial(num));//在输出函数里调用函数     return 0; }//定义函数int factorial(int num){    int c;    if(num==1||num==0)        c=1;    else if(num&lt;0)        printf(&quot;参数出错&quot;);    else        c=factorial(num-1)*num;     return c;}</code></pre><h2 id="7-7-数组作为函数参数"><a href="#7-7-数组作为函数参数" class="headerlink" title="7.7    数组作为函数参数"></a>7.7    数组作为函数参数</h2><p>凡是变量可以出现的地方，都可以用数组元素代替。用法与变量相同。</p><p>传递数组名，传递的是第一个元素地址。</p><h3 id="7-7-1-数组元素作函数实参"><a href="#7-7-1-数组元素作函数实参" class="headerlink" title="7.7.1    数组元素作函数实参"></a>7.7.1    数组元素作函数实参</h3><p>数组元素作函数实参时，把实参的值传给形参，是“值传递”方式。</p><pre><code class="c"># include &quot;stdio.h&quot;/*    练习用数组元素作为参数 */int main(){    int a[10],i,n,maxNum;    int max(int x,int y);//声明函数     printf(&quot;请依次输入10个数\n&quot;);    for(i=0;i&lt;10;i++)//分别对元素进行赋值    {        scanf(&quot;%d&quot;,&amp;a[i]);    }     for(i=1,maxNum=a[0];i&lt;10;i++)//调用函数     {        if(max(a[i],maxNum)&gt;maxNum)        {            maxNum=max(a[i],maxNum);            n=i+1;        }    }    printf(&quot;%d\t%d\n&quot;,maxNum,n);} //定义函数int max(int x,int y){    return x&gt;y?x:y;}</code></pre><h3 id="7-7-2-数组名作函数参数"><a href="#7-7-2-数组名作函数参数" class="headerlink" title="7.7.2    数组名作函数参数"></a>7.7.2    数组名作函数参数</h3><blockquote><p>用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数实参时，向形参传递的是数组元素的地址。</p></blockquote><pre><code class="c"># include &quot;stdio.h&quot;/*    练习用数组名作为参数 */int main(){    int i;    float a[10],av;    float average(float array[10]);//声明函数     printf(&quot;请依次输入10个数\n&quot;);    for(i=0;i&lt;10;i++)//分别对元素进行赋值    {        scanf(&quot;%f&quot;,&amp;a[i]);    }    av=average(a);    printf(&quot;%f&quot;,av);} //定义函数float average(float array[10]){    int i;    float sum,aver;    for(i=1,sum=array[0];i&lt;10;i++)    {        sum+=array[i];    }    aver=sum/10;    return aver;}/*实参与形参类型不一致，会出错形参数组可以不指定容量 可以这样定义：a[]*/</code></pre><pre><code class="c"># include &quot;stdio.h&quot;/*    练习用选择排序 */int main(){    int i;    float a[10],av;    void average(float array[],int n);//声明函数     printf(&quot;请依次输入10个数\n&quot;);    for(i=0;i&lt;10;i++)//分别对元素进行赋值    {        scanf(&quot;%f&quot;,&amp;a[i]);    }    average(a,10);    for(i=0;i&lt;10;i++)        printf(&quot;%f\n&quot;,a[i]);} //定义函数void average(float array[],int n){    int i,j,temp;    for(i=0;i&lt;n-1;i++)        for(j=i+1;j&lt;n;j++)        {            if(array[i]&gt;array[j])            {                temp=array[i];                array[i]=array[j];                array[j]=temp;            }        }}</code></pre><h3 id="7-7-3-多维数组作函数名"><a href="#7-7-3-多维数组作函数名" class="headerlink" title="7.7.3    多维数组作函数名"></a>7.7.3    多维数组作函数名</h3><p>可以作为函数的实参和形参，可以省略第一维的大小，第二维不能省略，C语言编译系统不检查第一维的大小。</p><h2 id="7-8-局部变量和全局变量"><a href="#7-8-局部变量和全局变量" class="headerlink" title="7.8    局部变量和全局变量"></a>7.8    局部变量和全局变量</h2><h3 id="7-8-1-局部变量"><a href="#7-8-1-局部变量" class="headerlink" title="7.8.1 局部变量"></a>7.8.1 局部变量</h3><p>定义变量的位置</p><ol><li>函数的开头定义</li><li>函数内的复合语句内定义</li><li>函数外都定义</li></ol><p>在复合语句内定义的变量旨在本复合语句范围内有效（花括号范围内），在本复合语句内才能引用他们。复合语句内不能使用，这被成为局部变量。</p><p>形式参数也是局部变量。</p><h3 id="7-8-2-全局变量"><a href="#7-8-2-全局变量" class="headerlink" title="7.8.2    全局变量"></a>7.8.2    全局变量</h3><blockquote><p>全局变量：函数外部定义的变量成为外部变量，外部变量也称全程变量</p></blockquote><p>作用范围：定义行到主函数结束，程序是从主函数开始到主函数结束</p><p>全局变量采用大驼峰命名</p><p>全局变量与局部变量重名，局部变量优先</p><p>如：</p><pre><code class="c"># include &quot;stdio.h&quot; int a=3,b=5; int main() {     int max(int a,int b);     int a=8;     printf(&quot;the max num is %d \n&quot;,max(a,b)); } int max(int a,int b) {     return a&gt;b?a:b; }结果：the max num is 8</code></pre><h2 id="7-9-变量的存储方式和生存期"><a href="#7-9-变量的存储方式和生存期" class="headerlink" title="7.9    变量的存储方式和生存期"></a>7.9    变量的存储方式和生存期</h2><h3 id="7-9-1-动态存储方式和静态存储方式"><a href="#7-9-1-动态存储方式和静态存储方式" class="headerlink" title="7.9.1    动态存储方式和静态存储方式"></a>7.9.1    动态存储方式和静态存储方式</h3><p>从空间(作用域)的角度来观察，变量可以分为全局变量和局部变量</p><p>从变量存在的时间(生存期)来看，变量存储存储方式有两种：</p><ul><li>静态存储：在程序运行期间由系统分配固定的存储空间的方式。</li><li>动态存储：在程序运行期间根据需要进行动态的分配存储空间。</li></ul><p>用户可以使用的内存存储空间结构：</p><ol><li>程序区</li><li>静态存储区</li><li>动态存储区</li></ol><p>全局按量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕后就释放。</p><p>动态存储区存放：</p><ol><li>函数形式参数。在调用函数时给形参分配存储空间。</li><li>函数中定义的没有用关键字static声明的变量，自动变量</li><li>函数调用时的现场保护和返回地址。</li></ol><p>在函数调用开始时分配动态存储空间，函数结束时释放这些空间。</p><p>在程序执行过程中，同一个程序调用两次相同函数，两次分配的给这些局部变量的存储空间地址可能是不相同的。</p><p>每个函数中的局部变量生存期只是程序执行期的一部分。</p><p>在程序执行过程中，先后调用函数，动态分配和释放空间。</p><blockquote><p>C语言中，<strong>数据类型</strong>和<strong>数据存储类别</strong>是<strong>变量</strong>和<strong>函数</strong>的属性。</p></blockquote><h3 id="7-9-2-局部变量的存储类别"><a href="#7-9-2-局部变量的存储类别" class="headerlink" title="7.9.2    局部变量的存储类别"></a>7.9.2    局部变量的存储类别</h3><p>1.自动变量（auto变量）</p><p>函数中的形参和函数中局部变量，都是动态分配的，调用该函数是，系统会给这些变量分配存储空间，在函数调用结束后，就会自动释放这些存储空间。这类局部变量称为自动变量。</p><blockquote><p>1.以auto修饰的变量    2.没有关键字修饰的。默认为自动变量</p></blockquote><p>2.静态局部变量(static局部变量)</p><p>局部变量的值在函数调用后结束不小时而继续保留原值，即不释放存储空间，在下次调用函数时，该变量已有值。这是该指定该局部变量为“静态局部变量”</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    void test();    test();    test();    return 0;} void test(){    static int a =1;    printf(&quot;%d\n&quot;,++a);}23--------------------------------Process exited after 0.01536 seconds with return value 0请按任意键继续. . .</code></pre><p>静态存储要多占内存，不能合理利用资源（和动态存储对比），且降低了程序的可读性，因此，若非必要，不要多用静态局部变量。</p><p>3.寄存器变量（register变量）</p><p>用于提高效率，寄存器的存取速度远大于内存的存取速度。</p><p>关键字是: register int f</p><p>寄存器变量存储在CPU中的寄存器中。</p><h3 id="7-9-3-全局变量的存储类别"><a href="#7-9-3-全局变量的存储类别" class="headerlink" title="7.9.3    全局变量的存储类别"></a>7.9.3    全局变量的存储类别</h3><p>全局变量都是存放于静态存放区中的，因此它们的生存期（生命周期）是固定的。</p><p>作用域：定义行开始到本程序文件末尾</p><p><strong>1.一个文件内扩展外部变量的作用域</strong></p><p>在定义点之前的函数需要引用该外部变量，在引用之前用关键字externa对该变量作“外部变量声明”。</p><pre><code class="c"># include &quot;stdio.h&quot;int main(){    int max();    extern int A,B,C;//将外部变量的作用扩展到由此处开始。     scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;C);    printf(&quot;%d&quot;,max());    return 0;} int A,B,C;//定义外部变量int max(){    int m;    m=A&gt;B?A:B;    return m&gt;C?m:C; } </code></pre><blockquote><p>注意：</p><ol><li>建议吧外部函数定义写在所有函数之前，可以避免不必要的extern的声明。</li><li>使用extern时，类型名可以省略</li></ol></blockquote><p><strong>2.将外部变量作用域扩展到其他文件</strong></p><p>​    如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量Num,不能分别在两个文件找那个各自定义一个外部变量，连接时会出现“重复定义”的错误。</p><p>正确做法是：</p><blockquote><ol><li>在任意一个文件中定义外部变量</li><li>另一个文件中用extern对Num作“外部变量声明”。</li></ol></blockquote><p><strong>3.将外部变量的作用域限制在本文件中</strong></p><p>只限在本文件使用的外部变量，加关键字:static</p><p>static声明一个变量的作用：</p><ol><li>对局部变量用static声明，把分配静态存储区，该变量在整个程序执行期间不释放，其分配的空间始终存在。</li><li>对全局变量用static声明，该变量的作用域只限本文件模块。</li></ol><h3 id="7-9-4-存储类别小结"><a href="#7-9-4-存储类别小结" class="headerlink" title="7.9.4    存储类别小结"></a>7.9.4    存储类别小结</h3><p><strong>从作用域角度分析，有局部变量和全局变量</strong></p><p><strong>从生存期来区分，有静态存储和动态存储</strong></p><p><strong>从变量值存放的位置来区分，有内存中的动态存储区，内存中的静态存储区，CPU中的寄存器</strong></p><p><strong>作用域和生存期的概念：作用域是空间上的描述；生存期是时间的的描述</strong></p><p><strong>static对局部变量来说：使变量从动态存储转为静态存储；static对于全局变量来说：规定了其作用域</strong></p><h2 id="7-10-关于定义和声明"><a href="#7-10-关于定义和声明" class="headerlink" title="7.10    关于定义和声明"></a>7.10    关于定义和声明</h2><p>定义是声明的一种体现，如int a;</p><p>建立存储空间的声明称为定义(定义一个变量，分配内存空间)</p><p>不需要简历存储存储空间的声明称为声明。（如：int max(int);）</p><p><img src="https://i.loli.net/2020/06/11/LO6bweiaTElFZcs.png" alt="声明和定义的区别.png" loading="lazy"></p><p>外部变量只能定义一次，可多次声明。系统根据外部变量的定义分配存储单元，同时进行初始化。</p><h2 id="7-11-内部函数和外部函数"><a href="#7-11-内部函数和外部函数" class="headerlink" title="7.11    内部函数和外部函数"></a>7.11    内部函数和外部函数</h2><h3 id="7-11-1-内部函数"><a href="#7-11-1-内部函数" class="headerlink" title="7.11.1    内部函数"></a>7.11.1    内部函数</h3><p>在定义内部函数时，在函数名和函数类型的前面加static</p><p>即：</p><p>static 类型名 函数名（形参列表）</p><p>{</p><p>函数体</p><p>}</p><p>不用担心函数是否会与其他文件模块函数同名</p><h3 id="7-11-2-外部函数"><a href="#7-11-2-外部函数" class="headerlink" title="7.11.2    外部函数"></a>7.11.2    外部函数</h3><p>在定义函数时，在函数首部的最左端加关键字extern，这函数是外部函数。关键字省略，默认为外部函数。</p><p>如：</p><p>extern int fun(int a,int b)</p><p>{</p><p>​    函数体</p><p>}</p><p>在需要调用此函数的其他文件中，需要对此函数做声明，声明时需要加extern关键字。表示这是其他文件中定义的外部函数。</p><p>由于函数在本质上时外部的，在程序中经常要调用其他文件的外部函数，为了方便编程，C语言允许声明函数时可以省略extern</p><p>在调用方中声明一个函数，这个函数就是被调用函数的函数原型。</p><p>函数原型的作用：</p><blockquote><p>扩展函数的作用域。</p></blockquote><p>常见的例子就是 # include指令的使用，通过引入其他库函数，然后进行使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-ckDLXTEH&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;7-1为什么要用函数&quot;&gt;&lt;a href=&quot;#7-1为什么要用函数&quot; class=&quot;headerlink&quot; title=&quot;7.1为什么要用函数&quot;&gt;&lt;/a&gt;7.1为什么要用函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;函数就是功能，每个函数用来实现一个特定的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在程序设计中要善于利用函数，来减少重复编写程序段的工作量实现模块化设计。&lt;/p&gt;
&lt;p&gt;一个C程序可以由一个主函数和若干个其他函数构成&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>利用数组处理批量数据</title>
    <link href="https://www.nscblog.top/posts/2b72a7f0/"/>
    <id>https://www.nscblog.top/posts/2b72a7f0/</id>
    <published>2020-05-24T12:42:34.000Z</published>
    <updated>2020-08-23T06:14:08.957Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-EyRnuwZM" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><blockquote><p>数组特点：</p><ol><li>数组是一组有序数据的集合</li><li>用一个数组名和下标表示一个元素</li><li>数组中的所有元素都属于同一个数据类型</li></ol></blockquote><a id="more"></a><h2 id="6-1-怎样定义和引用一维数组"><a href="#6-1-怎样定义和引用一维数组" class="headerlink" title="6.1    怎样定义和引用一维数组"></a>6.1    怎样定义和引用一维数组</h2><h3 id="6-1-1-怎样定义一维数组"><a href="#6-1-1-怎样定义一维数组" class="headerlink" title="6.1.1    怎样定义一维数组"></a>6.1.1    怎样定义一维数组</h3><p>语法：</p><p>类型符 数组名[常量表达式]   如：</p><p>int  a[10];</p><p>说明：</p><ol><li>数组命名规则与变量名相同，遵循标识符命名规则。</li><li>定义数组是，需要指定长度。</li><li>常量表达式可以包括常量和符号常量</li><li>数组在内存中是一片连续的空间。</li></ol><p>在非主函数中定义数组，其长度可以是变量或非常量表达式。</p><p>如果指定数组为静态存储方式，则不能用“可变长数组”。如:</p><p>static int a[2*n]</p><h3 id="6-1-2-怎样引用一维数组和元素"><a href="#6-1-2-怎样引用一维数组和元素" class="headerlink" title="6.1.2    怎样引用一维数组和元素"></a>6.1.2    怎样引用一维数组和元素</h3><p>引用数组元素的表示形式：</p><p>数组名[下标]           </p><p>注意：</p><p>下标可以是整形常量或整形表达式。</p><p>​    a[0]=a[5]+a[7]-a[2*3];</p><p>数组下标范围是0到（定义长度-1）</p><pre><code class="c"># include &lt;stdio.h&gt;int main(){    int a[10],i=9,j=0;    for(;j&lt;10;j++)        a[j]=j;    for(;i&gt;=0;i--)        printf(&quot;a[%d]=%d\n&quot;,i,a[i]);    return 0; } </code></pre><h3 id="6-1-3-一维数组的初始化"><a href="#6-1-3-一维数组的初始化" class="headerlink" title="6.1.3    一维数组的初始化"></a>6.1.3    一维数组的初始化</h3><ul><li><p>定义数组时对全部元素赋值</p><p>int a[5]={0,1,2,3,4};</p></li><li><p>可以给数组一部分元素赋值。</p><p>int a[10]={0,1,2,3};        //系统给后续元素赋值为0</p></li><li><p>如果想使一个数组中元素值为0，可以写成</p><p>int a[3]={0,0,0};  或     int a[3]={0}；</p></li></ul><h3 id="6-1-4-一维数组程序举例"><a href="#6-1-4-一维数组程序举例" class="headerlink" title="6.1.4    一维数组程序举例"></a>6.1.4    一维数组程序举例</h3><pre><code class="c"># include &lt;stdio.h&gt;/*    利用数组来实现斐波那契数列 */int main (){    int a[20]={1,1};    int i,j;    for(i=2;i&lt;20;i++)    {        a[i]=a[i-1]+a[i-2];    }     for(i=0;i&lt;20;i++)    {        printf(&quot;a[%d]=%d\n&quot;,i,a[i]);    }    return 0; }</code></pre><pre><code class="c">#include&lt;stdio.h&gt;/*     用一维数组实现冒泡排序 */ int main(){    int a[5]={1,6,7,8,5};    int i,j=0,temp=0;    for(i=0;i&lt;5;i++)    {        for(j=0;j&lt;5-i;j++)        {            if(a[j]&gt;a[j+1])            {                temp=a[j];                a[j]=a[j+1];                a[j+1]=temp;                }        }    }    for(i=0;i&lt;5;i++)    {        printf(&quot;a[%d]=%d\n&quot;,i,a[i]);    }    return 0;}</code></pre><h2 id="6-2-怎样定义和引用二维数组"><a href="#6-2-怎样定义和引用二维数组" class="headerlink" title="6.2    怎样定义和引用二维数组"></a>6.2    怎样定义和引用二维数组</h2><p><strong>二维数组常称矩阵</strong></p><h3 id="6-2-1-怎样定义二维数组"><a href="#6-2-1-怎样定义二维数组" class="headerlink" title="6.2.1    怎样定义二维数组"></a>6.2.1    怎样定义二维数组</h3><p>二维数组定义的一般表现形式</p><p>类型说明符 数组名[常量表达式] [常量表达式];</p><p>如：</p><p>float  a[3] [4],b[4] [5];</p><p>定义a为3行4列的数组，b为5行10列的数组。</p><p><img src="https://i.loli.net/2020/06/11/6XvHaYC9cbWNQFz.png" alt="C语言对二维数组的定义.png" loading="lazy"></p><p>C语言中二维数组中元素的排列的顺序是按行存放的，即在内存中存放第一行的元素，接着再存放第二行的元素。</p><p><strong>内存中中的个元素是连续存放的，不是二维的，是线性的</strong>。</p><p><img src="https://i.loli.net/2020/06/11/7TvhIQyUxEu8aqe.png" alt="多维数组的定义.png" loading="lazy"></p><h3 id="6-2-2-怎样引用二维数组"><a href="#6-2-2-怎样引用二维数组" class="headerlink" title="6.2.2    怎样引用二维数组"></a>6.2.2    怎样引用二维数组</h3><p>二维数组元素的表示形式为</p><p>数组名[下标] [下标]        下标应是整形表达式（对常量使用运算符连接进行运算）</p><h3 id="6-2-3-二维数组的初始化"><a href="#6-2-3-二维数组的初始化" class="headerlink" title="6.2.3    二维数组的初始化"></a>6.2.3    二维数组的初始化</h3><ol><li>分行给二维数组赋初值<img src="https://i.loli.net/2020/06/11/JX5Vp7UDsaHrnRP.png" alt="分行给二维数组赋值.png" loading="lazy"></li><li>可以，将所有数据卸载一个花括号内，按数组元素在内存中的排列顺序对个元素赋值。<img src="https://i.loli.net/2020/06/11/2s5eDgEKhUpFYca.png" alt="将数据写在一个花括号内.png" loading="lazy"></li><li>可以对部分赋值。没有赋值的部分，系统会自动赋值为0<img src="https://i.loli.net/2020/06/11/XYDp9mhiB8AUVM4.png" alt="对部分元素赋值.png" loading="lazy"></li><li>如果对全部元素都赋值，则定义数组是对第一维长度可以不指定，但第二维的长度不能省。<img src="https://i.loli.net/2020/06/11/P8OnESZH4qyVaRF.png" alt="全部元素赋值省略第一维长度.png" loading="lazy"></li></ol><h3 id="6-2-4-二维数组程序举例"><a href="#6-2-4-二维数组程序举例" class="headerlink" title="6.2.4    二维数组程序举例"></a>6.2.4    二维数组程序举例</h3><pre><code class="c"># include &lt;stdio.h&gt;/*    二维数组元素互换 */int main(){    int a[2][3]={1,2,3,4,5,6};    int b[3][2];    int i,j;    for(i=0;i&lt;2;i++)    {        for(j=0;j&lt;3;j++)        {            b[j][i]=a[i][j];        }    }    for(i=0;i&lt;3;i++)    {        for(j=0;j&lt;2;j++)        {            printf(&quot;%d\t&quot;,b[i][j]);        }        printf(&quot;\n&quot;);     }    return 0;}</code></pre><pre><code class="c"># include &lt;stdio.h&gt;/*    找出二维数组中最大的数 */int main(){    int a[2][3]={1,2,3,4,5,6};    int max=a[0][0],i,j;    for(i=0;i&lt;2;i++)        for(j=0;j&lt;3;j++)        {            if(a[i][j]&gt;max)                max=a[i][j];        };    printf(&quot;max=%d&quot;,max);    return 0;}</code></pre><h2 id="6-3-字符数组"><a href="#6-3-字符数组" class="headerlink" title="6.3    字符数组"></a>6.3    字符数组</h2><h3 id="6-3-1-怎样定义字符数组"><a href="#6-3-1-怎样定义字符数组" class="headerlink" title="6.3.1    怎样定义字符数组"></a>6.3.1    怎样定义字符数组</h3><p>char c[10];</p><p>c[10]=’3’;</p><p>因为字符型数据是以ASCII码存放的，因此，也可以用整形数组存放字符</p><h3 id="6-3-2-字符数组的初始化"><a href="#6-3-2-字符数组的初始化" class="headerlink" title="6.3.2    字符数组的初始化"></a>6.3.2    字符数组的初始化</h3><p>一次将各个字符赋值给数组中各元素。</p><p>部分赋值元素，剩余没有赋值的部分被系统自定义为空字符   ‘\0’</p><p>不赋值，默认是null 即  ‘\0’</p><h3 id="6-3-3-怎样引用字符数组中的元素"><a href="#6-3-3-怎样引用字符数组中的元素" class="headerlink" title="6.3.3    怎样引用字符数组中的元素"></a>6.3.3    怎样引用字符数组中的元素</h3><p>可以引用字符数组中一个元素，得到一个字符。</p><h3 id="6-3-4-字符串和字符串结束的标志"><a href="#6-3-4-字符串和字符串结束的标志" class="headerlink" title="6.3.4    字符串和字符串结束的标志"></a>6.3.4    字符串和字符串结束的标志</h3><p>在C语言中是将字符串作为字符数组来处理的。</p><p>C语言规定了一个“字符串结束的标志”，以null   即’\0’   作为结束标志。</p><p>如果字符数组中存有若干个字符，前9个字符都不是空字符，而地10个是’\0’ ，它的有效字符为9个，也就是说遇到字符’\0’时，表示字符串结束，把它前面的字符组成一个字符串。</p><p><strong>null字符的位置决定了字符数组的长度，或是字符串的长度。</strong></p><p>字符数组初始化一种方法：使用字符串常量来使字符数组初始化。</p><p>如：char c[]={“i am student.”};也可以省略花括号</p><p>​        char c[]=”i am student.”;  空字符也是字符串的长度的一部分，字符串的长度还要加一个空字符的位置。</p><p>​        char c[]=”i am student.”;等价于a[]  与d[]不一样</p><p>​        char a[]={‘i’,’ ‘,’a’,’m’,’ ‘,’s’,’t’,’u’,’d’,’e’,’n’,’t’,’.’,’\0’};</p><p>​        char d[]={‘i’,’ ‘,’a’,’m’,’ ‘,’s’,’t’,’u’,’d’,’e’,’n’,’t’,’.’};</p><p>说明：字符数组并不要求它的最后一个字符为null，甚至可以没有null</p><p>​            但为了处理方法一致，便于测定字符串的实际长度，在字符数组中加一个’\0’.便于引用字符数组中的字符串。</p><h3 id="6-3-5-字符数组的输入输出"><a href="#6-3-5-字符数组的输入输出" class="headerlink" title="6.3.5    字符数组的输入输出"></a>6.3.5    字符数组的输入输出</h3><p>字符数组的输入输出：</p><p>1.逐个字符输入输出，用格式符  %c  输出或输入一个字符</p><p>2.将整个字符串一次输入或输出。用%s格式符</p><p>​    如： char c[]={“chair”};</p><p>​            printf(“%s\n”,c);</p><p>说明：</p><ol><li><p>输出字符不包括’\0’</p></li><li><p>使用%s时，printf函数中输出项是字符数组名，而不是数组元素名。</p></li><li><p>如果数组长度大于字符串时，当检测到null时结束</p></li><li><p>当数组中包含多个null是，遇到第一个null输出结束</p></li><li><p>可以用scanf函数输入一个字符串。如：scanf(“%s”,c);</p><p>scanf函数输入项是字符数组名，不需要使用地址符，因为在C语言中数组名代表该数组的起始位置。</p></li><li><p>printf(“%s\n”,c); 执行过程，找到数组名c的起始位置，然后逐个输出其中的字符。直到遇到null 即’\0’时停止</p></li></ol><h3 id="6-3-6-使用字符串处理函数"><a href="#6-3-6-使用字符串处理函数" class="headerlink" title="6.3.6    使用字符串处理函数"></a>6.3.6    使用字符串处理函数</h3><h4 id="puts函数-输出字符串的函数"><a href="#puts函数-输出字符串的函数" class="headerlink" title="puts函数    输出字符串的函数"></a>puts函数    输出字符串的函数</h4><p>puts(字符数组) 作用是将一个字符串（以’\0’结束的字符序列）输出到终端。</p><h4 id="gets函数-输入字符串的函数"><a href="#gets函数-输入字符串的函数" class="headerlink" title="gets函数    输入字符串的函数"></a>gets函数    输入字符串的函数</h4><p>gets(字符数组)    目的是向字符数组输入一个字符串</p><blockquote><p>注意puts和gets函数只能输出或输入一个字符串</p></blockquote><h4 id="strcat函数-字符串连接函数"><a href="#strcat函数-字符串连接函数" class="headerlink" title="strcat函数    字符串连接函数"></a>strcat函数    字符串连接函数</h4><p>strcat(字符数组1，字符数组2)，作用是将两个字符串连接起来</p><blockquote><p>说明：</p><ol><li>字符数组1必须足够大，才能容纳连接后的新字符串。</li><li>连接后，字符串1的’\0’取消，只保留字符串2的’\0’</li></ol></blockquote><h4 id="strcpy和strncpy-字符串复制函数"><a href="#strcpy和strncpy-字符串复制函数" class="headerlink" title="strcpy和strncpy    字符串复制函数"></a>strcpy和strncpy    字符串复制函数</h4><p>strcpy(字符数组1，字符串2)   将字符串2复制到字符数组1</p><blockquote><p>说明：</p><ol><li>字符数组1的长度要等于或大于字符串2</li><li>字符数组1必须是数组名，字符串2既可以是字符数组名，也可以是一个字符串常量。</li><li>字符串2会替换掉字符数组1前字符串2的字符，剩余的不变</li><li>不能使用赋值语句将一个字符串常量或字符数组直接给一个字符数组。只能使用strcpy函数将字符串赋值到另一个字符数组里去。</li><li>可以使用strncpy函数将字符串2前面n个字符赋值到字符数组1去。   strncpy(字符数组1，字符串2，几个字符);</li></ol></blockquote><h4 id="strcmp函数-字符串比较函数"><a href="#strcmp函数-字符串比较函数" class="headerlink" title="strcmp函数    字符串比较函数"></a>strcmp函数    字符串比较函数</h4><p>strcmp(字符串1，字符串2)     比较字符串1和字符串2  比较的是内容是值</p><blockquote><p>说明：</p><ol><li>比较规则:将两个字符串自左到右逐个字符相比（按ASCII码值进行比较）直到出现不同字符或遇到’\0’为止</li><li>全部字符相同，则认为两个字符串相等；</li><li>如果出现不相同字符，则以第一对不相同的字符比较结果为准。</li><li>不能直接使用数组名比较字符串，只能用strcmp函数进行比较</li></ol></blockquote><p>strcmp的返回值 </p><ol><li>0代表两个字符串相等</li><li>正整数表示字符串1&gt;字符串2</li><li>负整数表示字符串1&lt;字符串2</li></ol><h4 id="strlen-函数-测试字符串长度的函数"><a href="#strlen-函数-测试字符串长度的函数" class="headerlink" title="strlen 函数   测试字符串长度的函数"></a>strlen 函数   测试字符串长度的函数</h4><p>strlen(字符数组);</p><p>函数的值为字符串的实际长度，不包括’\0’</p><h4 id="strlwr函数-转换为小写"><a href="#strlwr函数-转换为小写" class="headerlink" title="strlwr函数    转换为小写"></a>strlwr函数    转换为小写</h4><p>strlwr(字符串)；</p><p>将字符串中大写字母转换为小写。</p><h4 id="strupr函数-转换为大写"><a href="#strupr函数-转换为大写" class="headerlink" title="strupr函数    转换为大写"></a>strupr函数    转换为大写</h4><p>strupr(字符串);</p><p>将字符串中小写字母转换为大写。</p><blockquote><p>库函数是由编译系统提供，不同的编译系统提供的函数可能不同。</p><p>在使用字符串处理函数是，应当在程序文件的开头用#include&lt;string.h&gt;</p></blockquote><h3 id="6-3-7-字符数组应用举例"><a href="#6-3-7-字符数组应用举例" class="headerlink" title="6.3.7    字符数组应用举例"></a>6.3.7    字符数组应用举例</h3><p>看书上</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-EyRnuwZM&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;数组特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组是一组有序数据的集合&lt;/li&gt;
&lt;li&gt;用一个数组名和下标表示一个元素&lt;/li&gt;
&lt;li&gt;数组中的所有元素都属于同一个数据类型&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>循环结构程序设计</title>
    <link href="https://www.nscblog.top/posts/6d0a7f0b/"/>
    <id>https://www.nscblog.top/posts/6d0a7f0b/</id>
    <published>2020-05-18T12:42:16.000Z</published>
    <updated>2020-08-23T06:14:23.776Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-DBgUqTSz" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="5-1-为什么需要循环控制"><a href="#5-1-为什么需要循环控制" class="headerlink" title="5.1    为什么需要循环控制"></a>5.1    为什么需要循环控制</h2><p>用于处理需要进行重复的操作。</p><a id="more"></a><h2 id="5-2-用while语句实现循环"><a href="#5-2-用while语句实现循环" class="headerlink" title="5.2    用while语句实现循环"></a>5.2    用while语句实现循环</h2><p>语法结构:</p><pre><code class="markdown">while(表达式) 语句语句就是循环体：可以是单条语句，也可以是复合语句表达式被称为循环条件表达式：表达式的值为非0（真）时就执行循环体语句特点：先判断，在执行。</code></pre><blockquote><p>注意：</p><ol><li>循环体如果是多个语句，应该用花括号括起来，作为复合语句的出现。</li><li>必须给i和sum赋初始值，否则值是随机的。</li><li>循环体中应有使循环趋向于结束的语句。</li></ol></blockquote><h2 id="5-3-用do…-while语句实现循环"><a href="#5-3-用do…-while语句实现循环" class="headerlink" title="5.3    用do….while语句实现循环"></a>5.3    用do….while语句实现循环</h2><p>语法结构</p><pre><code class="markdown">do    语句while(表达式);特点：先执行一次循环体，然后判断条件是否成立。条件成立，再执行循环体。</code></pre><p>一般情况下，while和do/while处理同一问题时，若二者的循环体部分一样，name结果也一样。</p><h2 id="5-4-用for语句实现循环"><a href="#5-4-用for语句实现循环" class="headerlink" title="5.4    用for语句实现循环"></a>5.4    用for语句实现循环</h2><p>可以完全代替while语句，for语句更为灵活。</p><p>语法结构：</p><p>for(表达式1;表达式2;表达式3)</p><p>​    语句</p><p>3个边大师的主要作用：</p><p>表达式1：设置初始条件，只执行一次，可以为零个，一个或多个变量设置初值</p><p>表达式2：循环条件表达式，循环的判断。</p><p>表达式3：作为循环的调整，例如使循环变量增值，它是执行完循环体后才进行的</p><p>for语句的执行过程如下：</p><ol><li>执行表达式1</li><li>执行表达式2，表达式值为真，则执行循环体，然后执行第3步，为假，则结束循环转到第5步。</li><li>执行表达式3.</li><li>执行第2步</li><li>结束循环</li></ol><blockquote><p>可以在for语句外设置表达式1</p><p>可以在for语句循环体内设置表达式3</p><p>不写表达式2,判断条件为真 即非0</p></blockquote><p>注意:</p><ul><li><p>C99支持在 表达式1里进行变量定义赋值，C89支持赋值，不支持定义</p></li><li><p>表示式2只要不是值为非0任何表达式 就执行循环体</p></li></ul><h2 id="5-5-循环的嵌套"><a href="#5-5-循环的嵌套" class="headerlink" title="5.5    循环的嵌套"></a>5.5    循环的嵌套</h2><p>想想Java就行了</p><p><img src="https://i.loli.net/2020/06/11/loifPRhKg3GUtEs.png" alt="循环嵌套的方式.png" loading="lazy"></p><h2 id="5-6-几种循环的比较"><a href="#5-6-几种循环的比较" class="headerlink" title="5.6    几种循环的比较"></a>5.6    几种循环的比较</h2><ol><li><p>3种循环都可以用来处理同一问题，一般情况下他们可以相互代替。</p></li><li><p>while和do/while循环中，只在while后面括号内指定循环条件，为了能使循环能正常结束，循环体内包含驱使循环结束的语句。</p><p>for循环可以在表达式3中包含使循环趋于结束的操作，甚至可以将循环体语句放在表达式3中。因此for语句的功能更强。</p></li><li><p>while和do/while，循环变量初始化的操作应在while和do/while语句之前完成。</p></li><li><p>3种循环语句都可以用break跳出循环，continue语句结束本次循环</p></li></ol><h2 id="5-7-改变循环执行状态"><a href="#5-7-改变循环执行状态" class="headerlink" title="5.7     改变循环执行状态"></a>5.7     改变循环执行状态</h2><h3 id="5-7-1-用break语句提前终止循环"><a href="#5-7-1-用break语句提前终止循环" class="headerlink" title="5.7.1    用break语句提前终止循环"></a>5.7.1    用break语句提前终止循环</h3><p>作用是使流程跳出循环体之外，接着执行循环体下面的语句。</p><h3 id="5-7-2-用continue提前结束本次循环"><a href="#5-7-2-用continue提前结束本次循环" class="headerlink" title="5.7.2    用continue提前结束本次循环"></a>5.7.2    用continue提前结束本次循环</h3><p>作用：有时不希望终止整个循环的操作，而只希望提前结束本次循环，接着执行下次循环。</p><h3 id="5-7-3-break和continue的区别"><a href="#5-7-3-break和continue的区别" class="headerlink" title="5.7.3    break和continue的区别"></a>5.7.3    break和continue的区别</h3><p>continue：结束本次循环</p><p>break：终止整个循环的执行</p><p><img src="https://i.loli.net/2020/06/11/t4Nli5IuBK2wDRJ.png" alt="continue的练习题.png" loading="lazy"></p><pre><code class="c"># include &lt;stdio.h&gt;int main (){    int i,j;    for(i=1;i&lt;5;i++)    {        for(j=1;j&lt;=i*5;j++)        {            if(j%i!=0)                continue;            printf(&quot;%d\t&quot;,j);            }        printf(&quot;\n&quot;);    }    return 0;}</code></pre><h2 id="5-8-循环程序举例"><a href="#5-8-循环程序举例" class="headerlink" title="5.8    循环程序举例"></a>5.8    循环程序举例</h2><blockquote><p>getchar（）函数：不会直接读取用户输入字符，用户输入的字符输入后，会存入到缓冲区。后续可以接着用getchar（）调用，直到缓冲区中没有字符。</p></blockquote><p>说明：</p><ul><li><p>当用户键入回车之后，getchar才开始从stdin流中每次读入一个字符，getchar函数的返回值是用户输入的第一个字符的ASCII码。</p></li><li><p>如出错返回-1，且将用户输入的字符回显到屏幕，如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar调用读取。</p></li><li><p>也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才等待用户按键。</p></li></ul><pre><code class="c"># include &lt;stdio.h&gt;int main(){/*转换字符串（字母）*/     char c;    c=getchar();    while(c!=&#39;\n&#39;)    {        if((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)){            if((c&gt;=&#39;w&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;W&#39;&amp;&amp;c&lt;=&#39;Z&#39;))                c-=22;            else                c+=4;        }        printf(&quot;%c&quot;,c);        c=getchar();//从缓冲区中读取剩余的字符      }      printf(&quot;\n&quot;);    return 0;} </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-DBgUqTSz&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;5-1-为什么需要循环控制&quot;&gt;&lt;a href=&quot;#5-1-为什么需要循环控制&quot; class=&quot;headerlink&quot; title=&quot;5.1    为什么需要循环控制&quot;&gt;&lt;/a&gt;5.1    为什么需要循环控制&lt;/h2&gt;&lt;p&gt;用于处理需要进行重复的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>选择结构程序设计</title>
    <link href="https://www.nscblog.top/posts/a08e0173/"/>
    <id>https://www.nscblog.top/posts/a08e0173/</id>
    <published>2020-05-14T12:41:49.000Z</published>
    <updated>2020-08-23T06:14:32.951Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-vwNoQlDu" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="4-1-选择结构和判断条件"><a href="#4-1-选择结构和判断条件" class="headerlink" title="4.1 选择结构和判断条件"></a>4.1 选择结构和判断条件</h2><p>选择结构的关键：条件判断。</p><p>C语言选择语句：</p><ol><li>if语句 实现两个分支</li><li>switch语句，实现多分支的选择结构</li></ol><a id="more"></a><pre><code class="c">//使用if实现双分支选择结构# include &lt;stdio.h&gt;# include &lt;math.h&gt;//求方程实根 int main(){    double a,b,c,disc,x1,x2,p,q;//disc是判别式 b^2-4*a*c    printf(&quot;请分别输入a,b,c的值\n&quot;);    scanf(&quot;%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c);    printf(&quot;%f\t%f\t%f\t&quot;,a,b,c);    disc=pow(b,2)-4*a*c;    //disc大于0时才有实根    if(disc&lt;0){        printf(&quot;这个方程没有实根\n&quot;);    } else{        q=sqrt(disc)/(2.0*a);        p=-b/(2.0*a);        x1=p+q;        x2=p-q;        printf(&quot;x1=%.2f\t,x2=%.2f&quot;,x1,x2);    }     return 0;}</code></pre><h2 id="4-2-用if语句实现选择结构"><a href="#4-2-用if语句实现选择结构" class="headerlink" title="4.2    用if语句实现选择结构"></a>4.2    用if语句实现选择结构</h2><h3 id="4-2-1-用if语句处理选择结构举例"><a href="#4-2-1-用if语句处理选择结构举例" class="headerlink" title="4.2.1    用if语句处理选择结构举例"></a>4.2.1    用if语句处理选择结构举例</h3><pre><code class="c">//用if语句处理选择结构举例 # include &lt;stdio.h&gt;# include &lt;math.h&gt;//是两个值进行互换//关键是借助中间变量进行交换 int main(){    double a,b,temp;    printf(&quot;请分别输入a,b的值\n&quot;);    scanf(&quot;%lf%lf&quot;,&amp;a,&amp;b);    //a大于b时进行交换     if(a&lt;b){    } else{        temp=a;        a=b;        b=temp;    }     printf(&quot;%f\t%f&quot;,a,b);    return 0;}</code></pre><h3 id="4-2-2-if语句的一般形式"><a href="#4-2-2-if语句的一般形式" class="headerlink" title="4.2.2    if语句的一般形式"></a>4.2.2    if语句的一般形式</h3><p><strong>一般形式</strong> </p><p>​    if（表达式）语句1</p><p>​        [else 语句2]      //这个部分可以有，也可以没有</p><p><strong>常用三种形式</strong></p><ol><li><p>if (表达式) 语句1    没有else部分</p></li><li><p>if(表达式)</p><p>​    语句1</p><p>else</p><p>​    语句2</p></li><li><p>if(表达式1)   语句1    多层if语句</p><p>else if(表达式2)</p><p>else if(表达式3)</p><p>….</p><p>else</p></li></ol><p>注意：</p><ol><li>整个if语句可以卸载多行上。也可以卸载一行上</li><li>if(表达式){ 语句1 语句2 }   语句1 语句2属于内嵌语句，是if语句中的一部分。</li><li>if语句无论写在几行上，都是一个整体，属于同一个语句。</li><li>内嵌语句可以是简单语句，也可以是多种语句</li><li>表达式的值只能是逻辑值</li></ol><h2 id="4-3-关系运算符和关系表达式"><a href="#4-3-关系运算符和关系表达式" class="headerlink" title="4.3    关系运算符和关系表达式"></a>4.3    关系运算符和关系表达式</h2><h3 id="4-3-1-关系运算符及其优先次序"><a href="#4-3-1-关系运算符及其优先次序" class="headerlink" title="4.3.1    关系运算符及其优先次序"></a>4.3.1    关系运算符及其优先次序</h3><p><img src="https://i.loli.net/2020/06/11/65Njq7AIUhRSbM4.png" alt="关系运算符.png" loading="lazy"></p><p><strong>运算符的优先级</strong></p><p><img src="https://i.loli.net/2020/06/11/oqh2uTJWb58YNtC.png" alt="运算符优先级.png" loading="lazy"></p><h3 id="4-3-2-关系表达式"><a href="#4-3-2-关系表达式" class="headerlink" title="4.3.2    关系表达式"></a>4.3.2    关系表达式</h3><p>在C的逻辑运算中，以“1”代表真，以“0”代表“假”。</p><p>例：a=3,b=2,c=1</p><p>特殊情况：</p><p>d=a&gt;b 因为a&gt;b为真，因此关系表达式a&gt;b的值为1，所以赋值d后的值为1。</p><h2 id="4-4-逻辑运算符和逻辑表达式"><a href="#4-4-逻辑运算符和逻辑表达式" class="headerlink" title="4.4    逻辑运算符和逻辑表达式"></a>4.4    逻辑运算符和逻辑表达式</h2><h3 id="4-4-1-逻辑运算符及其优先次序"><a href="#4-4-1-逻辑运算符及其优先次序" class="headerlink" title="4.4.1    逻辑运算符及其优先次序"></a>4.4.1    逻辑运算符及其优先次序</h3><blockquote><p>逻辑表达式：用逻辑运算符将关系表达式或其他<strong>逻辑量</strong>连接起来的式子就是逻辑表达式</p></blockquote><p>&amp;&amp;：逻辑与：只要有量为假 表达式的值就为假</p><p>||：逻辑或：只要有量为真   表达式的值就为真</p><p>！：逻辑非</p><p><img src="https://i.loli.net/2020/06/11/Z3CsWJlFeUhwXou.png" alt="逻辑运算符.png" loading="lazy"></p><p>运算符的优先级：</p><ol><li><p>！&gt;&amp;&amp;&gt;||   从高到低排列</p></li><li><p>逻辑运算符中的“&amp;&amp;”和“||” 低于关系运算符，“!”高于算术运算符 </p><p><img src="https://i.loli.net/2020/06/11/5ibZe9kGK8gXjFf.png" alt="运算符的优先级.png" loading="lazy"></p><h3 id="4-4-2-逻辑表达式"><a href="#4-4-2-逻辑表达式" class="headerlink" title="4.4.2    逻辑表达式"></a>4.4.2    逻辑表达式</h3></li></ol><blockquote><p>逻辑表达式：用逻辑运算符将关系表达式或其他<strong>逻辑量</strong>连接起来的式子就是逻辑表达式</p></blockquote><p>逻辑表达式的值应该是一个逻辑量“真”或者“假”</p><p>判断结果时：以数值   1   代表真，以数值    0    代表假</p><p><strong>判断一个量时：以   0   代表假，以数值    非0   代表真</strong></p><p>如：设a的值等于4，则!a的值为0。因为a的值为非0，被认作是真，对它进行非运算，得“假”。“假”以0为代表。</p><p>注意：</p><ul><li>逻辑运算符两边的运算对象不但可以是0和1，或者是0和非0，也可以是字符型、浮点型、枚举型、或指针型的纯量型数据。</li><li>当a=1,b=2,c=3,d=4,m和n的原值为1是，由于“a&gt;b”的值为0，因此m=0，此时已经能判断整个表达式的值不可能为真。不必再进行”n=c&gt;d”的运算，因此n的值不是0，而仍保持原值1。</li></ul><h3 id="4-4-3-逻辑型变量"><a href="#4-4-3-逻辑型变量" class="headerlink" title="4.4.3    逻辑型变量"></a>4.4.3    逻辑型变量</h3><p>C99所增加的一种数据类型。语法：_Bool a;</p><p>在头文件stdbool.h中，将bool定义为_Bool的同义词，同时定义两个符号常量true和false  true代表1  false代表0</p><p>例如：</p><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;stdbool.h&gt; int main(){    _Bool a = false;    printf(&quot;--------------%d-----------------\n&quot;,a);    bool b = true;     printf(&quot;--------------%d-----------------\n&quot;,b);    return 0;} 运行结果：--------------0-------------------------------1-------------------------------------------------Process exited after 0.02229 seconds with return value 0请按任意键继续. . .</code></pre><blockquote><p>注意：</p><p>在使用bool之前，应该确定该编译系统是否能使用。</p></blockquote><h2 id="4-5-条件运算符的条件表达式"><a href="#4-5-条件运算符的条件表达式" class="headerlink" title="4.5    条件运算符的条件表达式"></a>4.5    条件运算符的条件表达式</h2><p>条件运算符：  逻辑表达式  ?  值为1时 执行     :   值为0时执行;</p><p>条件运算符是C语言中的唯一的三目运算符</p><h2 id="4-6-选择结构的嵌套"><a href="#4-6-选择结构的嵌套" class="headerlink" title="4.6    选择结构的嵌套"></a>4.6    选择结构的嵌套</h2><blockquote><p>在if语句中又包含一个或多个if语句称为if语句的嵌套</p></blockquote><p>表现形式：</p><pre><code class="c">if()    if()  语句1    else  语句2else    if()   语句3    else   语句4</code></pre><p>else 会就近匹配 if</p><p><img src="https://i.loli.net/2020/06/11/bgPFMVioYtHLjSm.png" alt="if-else就近匹配.png" loading="lazy"></p><h2 id="4-7-用switch语句实现多分支选择结构"><a href="#4-7-用switch语句实现多分支选择结构" class="headerlink" title="4.7    用switch语句实现多分支选择结构"></a>4.7    用switch语句实现多分支选择结构</h2><p>语法：</p><pre><code class="c">switch(表达式){case 常量1：语句1；break；case 常量2：语句2；break；.......default:  语句n;}</code></pre><p>说明：</p><ol><li>表达式的值类型应为整数类型（包括字符型）。</li><li>花括号内是一个复合语句，case 用来标记一个位置</li><li>可以没有default标号，没有与switch表达式相匹配的case常量，则不执行任何语句，流程转到switch语句的下一个语句。</li><li>标号的出现次序不影响执行结果</li><li>case常量必须互不相同，</li><li>case标号只起标记作用，根据switch表达式的值找到匹配的入口标号。</li><li>case子句中虽然包含了一个以上执行语句，但可以不必用花括号括起来，会自动顺序执行此case标号后的所有语句。</li><li>多个case标号可以共用一组执行语句。</li></ol><h2 id="4-8-选择结构程序综合举例"><a href="#4-8-选择结构程序综合举例" class="headerlink" title="4.8 选择结构程序综合举例"></a>4.8 选择结构程序综合举例</h2><p>例：判断一年是否是闰年</p><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;math.h&gt;# include &lt;stdbool.h&gt;/*判断一年是否是闰年 */int main(){    int year;    _Bool leap;    printf(&quot;请输入要判断的年份\n&quot;);    scanf(&quot;%d&quot;,&amp;year);    if(year%4==0&amp;&amp;year%100!=0||year%400==0)        leap=1;    else        leap=0;    //将leap作为判断输入年份是否是闰年    //leap=1 为闰年    //leap=0 不是闰年     if(leap)        printf(&quot;%d是闰年&quot;,year);    else        printf(&quot;%d不是闰年&quot;,year);    return 0;}</code></pre><p>例：求方程的根</p><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;math.h&gt;# include &lt;stdbool.h&gt;/*    求ax^2+bx+c=0的根 */int main(){    double a,b,c,desc,p,q,x1,x2; //desc=b^2-4ac;    printf(&quot;请分别输入a,b,c的值\n&quot;);    scanf(&quot;%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c);    if(!a)    //a=0时，二次方程不存在         printf(&quot;这不是二次方程&quot;);    else    {        desc=pow(b,2)-4*a*c;        if(desc==0)        {            printf(&quot;这个方程有两个相同的实根&quot;);            x1=-b/(2.0*a);            printf(&quot;x1=%d,x2=%d&quot;,x1,x1);        } else if(desc&lt;0)        {            printf(&quot;这个方程没有实根&quot;);        } else        {            p=sqrt(desc)/(2.0*a);            q=-b/(2.0*a);            x1=p+q;            x2=q-p;            printf(&quot;x1=%d\tx2=%d&quot;,x1,x2);         }     }     return 0;}</code></pre><p>例</p><pre><code class="c"># include &lt;stdio.h&gt;# include &lt;math.h&gt;# include &lt;stdbool.h&gt;/*    计算运输费用 */int main(){    int c,s;//c表示250的倍数，s表示里程    printf(&quot;请输入相应的里程数：\n&quot;);    float d,p,f,w;//d 表示折扣 便宜d%，p表示价格，f表示总价,w表示重量     scanf(&quot;%d&quot;,&amp;s);    printf(&quot;请输入相应的单价和重量：\n&quot;);    scanf(&quot;%f%f&quot;,&amp;p,&amp;w);     /*    计算里程倍数     */    if (s&gt;3000)         c=12;    else        c=s/250;    //统计折扣     if(c&gt;=12){        d=15;    } else if (8&lt;=c&amp;&amp;c&lt;=11){        d=10;    } else if (c&gt;=4&amp;&amp;c&lt;=7){        d=8;    } else if(c&gt;=2&amp;&amp;c&gt;=3){        d=5;    } else if(c&gt;0&amp;&amp;c&lt;=1){        d=2;    } else{        printf(&quot;没有优惠\n&quot;);        d=0;     }    printf(&quot;优惠%f\n&quot;,d/100);    //计算运费    f=p*w*s*(1-d/100);    printf(&quot;运输费用是%f\n&quot;,f);     return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-vwNoQlDu&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;4-1-选择结构和判断条件&quot;&gt;&lt;a href=&quot;#4-1-选择结构和判断条件&quot; class=&quot;headerlink&quot; title=&quot;4.1 选择结构和判断条件&quot;&gt;&lt;/a&gt;4.1 选择结构和判断条件&lt;/h2&gt;&lt;p&gt;选择结构的关键：条件判断。&lt;/p&gt;
&lt;p&gt;C语言选择语句：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;if语句 实现两个分支&lt;/li&gt;
&lt;li&gt;switch语句，实现多分支的选择结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>hexo+GitHub博客搭建</title>
    <link href="https://www.nscblog.top/posts/6121bfd7/"/>
    <id>https://www.nscblog.top/posts/6121bfd7/</id>
    <published>2020-05-01T08:52:43.000Z</published>
    <updated>2020-08-23T06:05:17.324Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-AzUPikAZ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1423285" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>我花了一些时间搭建属于自己的博客，曾经也弄过一些博客之类的，接触hexo之后，相对来说,hexo简单易用，灵活高效。</p><p>hexo+GitHub进行搭建相对自己购买服务器更为划算。花费的精力也比使用服务器要少很多。这样我们就可以更专注写博客。</p></blockquote><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先我们要将博客托管于GitHub所以我们先安装Git，使用Git进行代码的上传于维护。</p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><ol><li><p>从<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>上下载你计算机系统所对应的Git安装包</p></li><li><p>无脑下一步，进行安装</p></li><li><p>安装完成之后Win+R 输入cmd回车 输入 </p><pre><code class="markdown">git --version</code></pre><p>出现版本号，代表环境变量配置成功。没有配置成功的话</p><pre><code class="markdown">找到Git的安装路径将安装路径下的bin文件夹的路径添加到path变量中注意：bin文件夹存放是Git的一些二进制可执行命令。</code></pre></li><li><p>Git的一些基本操作和使用，我推荐<a href="https://wiki.jikexueyuan.com/project/git-tutorial/github.html" target="_blank" rel="noopener">极客学院的Git教程</a>，写的很清楚，跟着学基本使用不成问题。</p></li></ol><h2 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h2><ol><li><p>从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>上下载你计算机系统所对应的nodejs安装包，我们直接使用长期支持办就行。不推荐使用最新版，否则在后续过程会出现百度都没有的问题。如：</p><blockquote><p>TypeError [ERR_INVALID_ARG_TYPE]: The “mode” argument must be integer.</p></blockquote></li></ol><ol start="2"><li><p>无脑下一步，直接完事。</p><p>再次进入cmd 执行以下命令</p><pre><code class="markdown"> node -v  #查看nodejs的版本 npm -v #这我也不知道是啥，查看有没有相关工具</code></pre></li></ol><blockquote><p>安装Git和nodejs之后，我们直接使用git bash来敲命令行</p></blockquote><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><ol><li><p>先创建一个空文件夹blog，用于存放hexo的环境与博客文章，在blog文件内进行右单击后选择git bash here</p><p>输入命令</p><pre><code class="markdown">npm install -g hexo-cli</code></pre><p>老规矩，使用hexo -v 查看是否安装成功，顺便查看版本号</p></li><li><p>接下来初始化hexo</p><pre><code class="markdown">hexo init</code></pre><p>初始化完成后会有以下文件结构：</p><ul><li>node_modules：依赖包 即hexo所需的环境依赖</li><li>public：生成的页面的存放位置</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：hexo主题样式</li><li>.gitignore：上传到git时所要忽略的东西</li><li>_config.yml：全局的配置文件</li></ul></li><li><p>输入命令</p><pre><code class="markdown">hexo g #生成博客视图资源hexo s #启动后台服务器 会有http://localhost:4000</code></pre><p>在浏览器中输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行测试查看</p><p>使用Ctrl+C将服务器关闭</p></li></ol><h2 id="创建GitHub个人仓库"><a href="#创建GitHub个人仓库" class="headerlink" title="创建GitHub个人仓库"></a>创建GitHub个人仓库</h2><ul><li>首先创建一个GitHub账号，记得用户名</li><li>创建一个仓库（repository）仓库名是 用户名.github.io 如我的仓库名就是 t-diana.github.io</li></ul><h2 id="将SSH添加到GitHub"><a href="#将SSH添加到GitHub" class="headerlink" title="将SSH添加到GitHub"></a>将SSH添加到GitHub</h2><ul><li><p>记录本台机器一些信息</p><pre><code>#这里的yourname输入你的GitHub用户名git config --global user.name &quot;yourname&quot;#这里youremail输入你的GitHub的邮箱git config --global user.email &quot;youremail&quot;</code></pre></li><li><p>生成SSH公钥</p><pre><code class="markdown">ssh-keygen -t rsa -C &quot;youremail&quot;</code></pre><p>可以在用户主目录里找到<code>.ssh</code>目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></li><li><p>GitHub添加SSH </p><ol><li>登录GitHub</li><li>点击右上角头像，选择setting</li><li>选择SSH and GPG keys</li><li>点击 New SSH key</li><li>将id_rsa.pub里的内容全部复制到key中，取个title 点击Add SSH key</li></ol></li><li><p>在git bash 中查看是否添加成功</p><pre><code class="markdown">ssh -T git@github.com   #直接复制，不用修改</code></pre></li></ul><h2 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h2><p>对全局配置文件_config.yml(而不是themes下的 _config.yml)进行修改</p><pre><code class="yml">deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master#YourgithubName 就是自己的GitHub用户名</code></pre><p>然后需要先安装deploy-git，才能用命令将博客视图资源部署到GitHub上</p><pre><code class="markdown">npm install hexo-deployer-git --save #安装deploy-git的命令</code></pre><p>上传操作相关命令，每次写完文章后，执行相关的命令</p><pre><code class="shell">hexo clean #清除之前生成的博客视图资源hexo generate 或是 hexo g #生成静态文章hexo deploy 或是 hexo d #将资源上传到GitHub上</code></pre><blockquote><p>注意：</p><p>进行deploy时会需要输入username和password</p></blockquote><p>至此，博客基本搭建完成。如果需要进行其他修改的话。</p><p>大家可以查看<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">这篇博客</a>，这位博主写得非常细致。</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-AzUPikAZ&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;1423285&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我花了一些时间搭建属于自己的博客，曾经也弄过一些博客之类的，接触hexo之后，相对来说,hexo简单易用，灵活高效。&lt;/p&gt;
&lt;p&gt;hexo+GitHub进行搭建相对自己购买服务器更为划算。花费的精力也比使用服务器要少很多。这样我们就可以更专注写博客。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="博客搭建" scheme="https://www.nscblog.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>学习方法论</title>
    <link href="https://www.nscblog.top/posts/d0f7b26e/"/>
    <id>https://www.nscblog.top/posts/d0f7b26e/</id>
    <published>2020-05-01T08:26:36.000Z</published>
    <updated>2020-08-23T06:15:07.476Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-ZiERocaN" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="29089381" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h2><h3 id="世界观："><a href="#世界观：" class="headerlink" title="世界观："></a>世界观：</h3><p>​    不学习就不会产生进步，将会愚昧无知，自甘堕落。学习就是体验痛苦，重复同样的事物，却没有任何意思。我不喜欢学习，也不喜欢学习的成果，我想要的永远没有得到过。我只是在获取在这个世界的生存方式。</p><a id="more"></a><h3 id="方法论："><a href="#方法论：" class="headerlink" title="方法论："></a>方法论：</h3><h4 id="chapter1-拖延症"><a href="#chapter1-拖延症" class="headerlink" title="chapter1 拖延症"></a>chapter1 拖延症</h4><p>学习新事物的记忆区域与痛觉的区域再相同的地方（大脑），因而当你在学习新事物的，会加大堆脑部的压力。</p><p>要学会主动去做，天赋与才能的开始  (这是一种态度，也是很重要的思想)</p><h4 id="chapter2-记住学习的重要的东西，而不是重复学习"><a href="#chapter2-记住学习的重要的东西，而不是重复学习" class="headerlink" title="chapter2 记住学习的重要的东西，而不是重复学习"></a>chapter2 记住学习的重要的东西，而不是重复学习</h4><p>消耗时间回忆，不要持续学习新事物，大脑记忆新事物的重要性：弱势就是学习的需求</p><p>睡眠很重要，理由如下：</p><ul><li><p>可以缓解压力</p></li><li><p>将神经元上突触的毒素清除，创建更多的突触 将新事物的特点与旧事物进行连接</p></li><li><p>用于更好的学习新事物。</p></li></ul><h4 id="chapter3-即使有别人帮助你，还得靠自己"><a href="#chapter3-即使有别人帮助你，还得靠自己" class="headerlink" title="chapter3 即使有别人帮助你，还得靠自己"></a>chapter3 即使有别人帮助你，还得靠自己</h4><p>左脑(专注模式，逻辑模式)：记忆新事物，前提是注意力不被分散</p><p>右脑(散发模式)：大脑游走，表达事物。</p><p><strong>学习最大的部分解决问题</strong></p><h4 id="chapter4-变得吃力，却同时变得更加容易"><a href="#chapter4-变得吃力，却同时变得更加容易" class="headerlink" title="chapter4 变得吃力，却同时变得更加容易"></a>chapter4 变得吃力，却同时变得更加容易</h4><p>学习新事物       难点      找不到与之有关的联系</p><p>学习的表面:只知道名字和类别</p><p>学习的主要:<strong>最让你感觉到最真实的那部分。</strong></p><p>方向：</p><ul><li>有大体方向，不要卡在细节</li><li>当细节过后，补全细节</li></ul><h4 id="chapter5-你还得做大量的研究"><a href="#chapter5-你还得做大量的研究" class="headerlink" title="chapter5  你还得做大量的研究"></a>chapter5  你还得做大量的研究</h4><ol><li><p>错误是学习的一部分</p></li><li><p>有创意的人存在的问题：太过相信直觉认为正确的事情。</p></li><li><p>上手不等同于掌握 这样只有表面印在了我的大脑中 </p></li><li><p>要有练习的时间</p></li><li><p>学习一件事新事物，是在不同的事物之间来回，而不是同一事物间来回。这样可以存在空间复习出处理和学习事物。</p></li><li><p>过一段时间后，用练习和直觉来确实的学习事物。</p></li></ol><h4 id="chapter6-所有东西都与过程有关"><a href="#chapter6-所有东西都与过程有关" class="headerlink" title="chapter6 所有东西都与过程有关"></a>chapter6 所有东西都与过程有关</h4><p>拖延是正常的，学习新事物没有那么愉快。在学习新事物很难起手。</p><p>学习新事物的同时等同于在吃苦。</p><p>没有天赋与才能，天赋与才能的起点:I AM WILLING TO DO IT(我愿意去做)，通过天赋与才能获取到的事物只是附属品。</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-ZiERocaN&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;29089381&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;关于学习&quot;&gt;&lt;a href=&quot;#关于学习&quot; class=&quot;headerlink&quot; title=&quot;关于学习&quot;&gt;&lt;/a&gt;关于学习&lt;/h2&gt;&lt;h3 id=&quot;世界观：&quot;&gt;&lt;a href=&quot;#世界观：&quot; class=&quot;headerlink&quot; title=&quot;世界观：&quot;&gt;&lt;/a&gt;世界观：&lt;/h3&gt;&lt;p&gt;​    不学习就不会产生进步，将会愚昧无知，自甘堕落。学习就是体验痛苦，重复同样的事物，却没有任何意思。我不喜欢学习，也不喜欢学习的成果，我想要的永远没有得到过。我只是在获取在这个世界的生存方式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="方法论" scheme="https://www.nscblog.top/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>最简单的C程序设计——顺序程序设计</title>
    <link href="https://www.nscblog.top/posts/6b82abcf/"/>
    <id>https://www.nscblog.top/posts/6b82abcf/</id>
    <published>2020-03-27T12:41:13.000Z</published>
    <updated>2020-08-23T06:14:44.594Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-acukgUau" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="3-1-顺序程序设计举例"><a href="#3-1-顺序程序设计举例" class="headerlink" title="3.1    顺序程序设计举例"></a>3.1    顺序程序设计举例</h2><p>略,自己看资料理解</p><a id="more"></a><p><img src="https://i.loli.net/2020/06/11/urOSzHyIn432Lsp.png" alt="VisualC__6.0编译系统.png" loading="lazy"></p><h2 id="3-2-数据的表现形式及其运算"><a href="#3-2-数据的表现形式及其运算" class="headerlink" title="3.2    数据的表现形式及其运算"></a>3.2    数据的表现形式及其运算</h2><blockquote><p>程序中最基本的成分:数据成分,运算成分,控制成分,传输成分</p></blockquote><h3 id="3-2-1-常量和变量"><a href="#3-2-1-常量和变量" class="headerlink" title="3.2.1    常量和变量"></a>3.2.1    常量和变量</h3><blockquote><p>在计算机高级语言中,数据有两种表现形式:常量和变量</p></blockquote><h5 id="1-常量"><a href="#1-常量" class="headerlink" title="1.    常量"></a>1.    常量</h5><p>概念:程序运行过程中不能被改变的量</p><p>常量类型:</p><ol><li><p>整形常量</p></li><li><p>实型常量:1&gt;十进制小数形式;2&gt;指数形式</p></li><li><p>字符常量:普通字符常量(用单撇号括起来的);转义字符(以\开头的字符序列,如:\n)</p><p><strong>ASCII码的字符表示都可以通过该字符的八进制的进行转义</strong></p><p><img src="https://i.loli.net/2020/06/11/JbyLicHAt2uP7Qg.png" alt="转义字符及其作用.png" loading="lazy"></p></li><li><p>字符串常量:用双撇号将若干个字符括起来</p></li><li><p>符号常量</p><p>概念:使用# define指令,指定一个符号名称代表一个常量</p><p>如:    #define PI 3.1416</p><p>要求:1&gt;含义清楚,即见名知义;2&gt;多处使用到同一个常量是,能做到”一改全改”.</p><p>注意:</p><p>​        要区分符号常量和变量</p><p>​        符号常量不占内存只是一个临时符号,预编译后这个符号就不存在了,所以不能对符号常量赋新值</p></li></ol><h5 id="2-变量"><a href="#2-变量" class="headerlink" title="2.    变量"></a>2.    变量</h5><p>变量代表一个有名字的具有特定属性的一个存储单元,它用来存放数据(变量的值)</p><p>变量先声明,后使用.</p><p><img src="https://i.loli.net/2020/06/11/VPJQ5oayq9zn612.png" alt="变量的样子.png" loading="lazy"></p><p>变量名实际上是一个以名字为代表的一个存储地址，在对程序编译连接时由编译系统给每一个变量名分配对应的内存地址。从变量中取值,实际上是通过变量名找到相应的内存地址,从该存储单元中读取值。</p><h5 id="3-常变量"><a href="#3-常变量" class="headerlink" title="3.    常变量"></a>3.    常变量</h5><p>由const进行修饰</p><p>如:const float pi =3.1415926</p><p>符号常量和常变量的异同</p><p>​    常变量:具有变量的基本属性:有类型,占存储单元.不能改变值,可以在程序中被引用.</p><p>​             具有符号常量的优点,使用方便</p><p>​    符号常量:没有占存储单元</p><p>​                 在预编译时进行字符串替换</p><h5 id="4-标识符"><a href="#4-标识符" class="headerlink" title="4.    标识符"></a>4.    标识符</h5><p>只能由字母,数字,下划线组成,且第一个字符必须为字母或下划线</p><p>严格区分大小写</p><h3 id="3-2-2-数据类型"><a href="#3-2-2-数据类型" class="headerlink" title="3.2.2    数据类型"></a>3.2.2    数据类型</h3><p>在数学中,数值是抽象的</p><p>在计算机,数据是存放在存储单元中的,它是具体存在的,存放数据范围是有限的</p><p>单精度是小数点后6位</p><p><img src="https://i.loli.net/2020/06/11/JV14krTOXcBSfPW.png" alt="数据类型.png" loading="lazy"></p><ul><li><p>基本类型和枚举类型变量的值都是数值.统称算术类型</p></li><li><p>算术类型和指针类型统称为纯量类型(标量类型):变量值是以数字表示的,枚举类型是程序中用户定义的整数类型.</p></li><li><p>枚举类型是程序中用户定义的整数内容(枚举类型的值只能是整数类型)</p></li><li><p>数组类型和结构体类型统称为组合类型,共用体类型不属于组合类型因为在同一时间内只能有一个成员具有值.</p></li><li><p>函数类型:用于定义函数,描述函数的接口,包括(函数返回值的数据类型和参数的类型)</p></li></ul><h3 id="3-2-3-整形数据"><a href="#3-2-3-整形数据" class="headerlink" title="3.2.3    整形数据"></a>3.2.3    整形数据</h3><h5 id="1-基本整形-int型"><a href="#1-基本整形-int型" class="headerlink" title="1.基本整形(int型)"></a>1.基本整形(int型)</h5><p>编译系统分配给int型数据2个字节或4个字节(由具体的C编译系统决定)</p><p>Visual C++为每个整形分配四个字节</p><p> 存储单元的存放方式:用整数的补码进行存放</p><p>正整数的补码就是原码</p><p>负数的补码是正整数的原码按位取反,进行加一</p><p><img src="https://i.loli.net/2020/06/11/6G3sbULHBklmrfy.png" alt="补码原码反码.png" loading="lazy"></p><p>十进制转二进制:</p><p><img src="https://i.loli.net/2020/06/11/XnEVwDIW7hatB83.jpg" alt="十进制转二进制.jpg" loading="lazy"></p><h5 id="2-短整型"><a href="#2-短整型" class="headerlink" title="2.    短整型"></a>2.    短整型</h5><p>Visual C++ 分配2个字节</p><h5 id="3-长整形"><a href="#3-长整形" class="headerlink" title="3.    长整形"></a>3.    长整形</h5><p>Visual C++ 分配4个字节</p><p><img src="https://i.loli.net/2020/06/11/4gn7aSruBK8Vict.png" alt="整形常见的存储空间和值的范围.png" loading="lazy"></p><p>注意:</p><p>​    只有整形包括字符型数据可以加signed或unsigned,实型数据不能加</p><p>​    无符号整形数据用”%u”格式进行输出,%u表示用无符号十进制数的格式输出</p><h3 id="3-2-4-字符型数据"><a href="#3-2-4-字符型数据" class="headerlink" title="3.2.4    字符型数据"></a>3.2.4    字符型数据</h3><h5 id="1-字符与字符代码"><a href="#1-字符与字符代码" class="headerlink" title="1.    字符与字符代码"></a>1.    字符与字符代码</h5><p>在程序中,只能使用系统字符集中的字符,目前大多数采用ASCII字符集.</p><p><img src="https://i.loli.net/2020/06/11/AITf62XHqtn8r51.png" alt="常用的ASCII码.png" loading="lazy"></p><h5 id="2-字符变量"><a href="#2-字符变量" class="headerlink" title="2.    字符变量"></a>2.    字符变量</h5><p>关键字:char 如:</p><p>char a = ‘b’</p><p>这个声明变量并且赋值的意思是将字符 b 对应的ASCII码赋值给变量名为a这个字符变量</p><p>输出时可以选择十进制输出,或选择字符形式输出</p><p>“%d”:十进制输出</p><p>“%c”:字符形式输出</p><p>Q:字符类型也属于整形,是否也可以使用signed和unsigned修饰符?</p><p>A：</p><ul><li><p>可以</p></li><li><p>第一位(8位二进制表示的数),表示符号位:数据范围就是:0-127(相当于使用了signed进行修饰)</p></li><li><p>第一位不表示符号位,数据表示可以从0-255(使用了unsigned进行修饰)</p></li></ul><h4 id="3-2-5-浮点型数据"><a href="#3-2-5-浮点型数据" class="headerlink" title="3.2.5    浮点型数据"></a>3.2.5    浮点型数据</h4><p>在C语言中实数以指数形式存储，如图</p><p><img src="https://i.loli.net/2020/06/11/kT8NEGSp2nMcCFh.png" alt="实数的构成.png" loading="lazy"></p><p>比如：3.1416 可以表示为3.14159x10^0  0.314159x10^1</p><p><strong>移动小数点位置的同时改变指数的值，就可以保证它的值不会变</strong></p><p>小数部分占的位数越多，表示精度大</p><p>指数部分占的位数越多，表示范围越大</p><p>浮点数类型有：float   double</p><p><img src="https://i.loli.net/2020/06/11/iyzK58IwEZgORUH.png" alt="实型数据的有关情况.png" loading="lazy"></p><p>注意：C编译系统把浮点型常量按双精度处理。</p><h4 id="3-2-6-怎样确定常量的类型"><a href="#3-2-6-怎样确定常量的类型" class="headerlink" title="3.2.6    怎样确定常量的类型"></a>3.2.6    怎样确定常量的类型</h4><p>整形常量：不带小数点的数值是整形常量。</p><p>浮点型常量：凡是以小数形式出现的实数。</p><p>区分类型和变量：</p><p>类型：是变量的一个属性，代表的是一类型的数据。比如： 大学生</p><p>变量：占用存储单元，是具体存在的实体。如 大学生 我</p><p>大学生是抽象的  而我是具体的</p><h4 id="3-2-7-运算符和表达式"><a href="#3-2-7-运算符和表达式" class="headerlink" title="3.2.7    运算符和表达式"></a>3.2.7    运算符和表达式</h4><p>1.基本的算术运算符</p><p><img src="https://i.loli.net/2020/06/11/BFbM5K3pHGPgXQI.png" alt="常用的算术预算符.png" loading="lazy"></p><p>2.自增、自减运算符</p><p><strong>注意：自增、自减运算符只能用于变量，不能用于常量或表达式</strong></p><p>3.算术表达式和运算符的优先级与结合性</p><p>算术运算符中的数如果只能float，那将数值转为float，进行计算，如果有double 就转为double进行计算，float和double都有，就转为double进行计算</p><p><img src="https://i.loli.net/2020/06/11/tX9gzvlJaYduoZ6.png" alt="C预算符1.png" loading="lazy"></p><p><img src="https://i.loli.net/2020/06/11/FpOZj5qstVwAY7d.png" alt="C语言运算符2.png" loading="lazy"></p><h2 id="3-3-C语句"><a href="#3-3-C语句" class="headerlink" title="3.3 C语句"></a>3.3 C语句</h2><p>一个函数包含声明部分和执行部分，执行部分由C语句组成</p><p><img src="https://i.loli.net/2020/06/11/SVI1yTgK9tdNxfC.png" alt="C语言程序构成.png" loading="lazy"></p><p>C语句分类：</p><ol><li><p>控制语句</p><p>条件语句</p><p>循环语句</p><p>continue  结束本次循环语句</p><p>break  终止执行switch或循环语句</p><p>switch 多分支选择语句</p><p>return 函数返回语句</p><p>goto 转向语句，在结构化过程中基本不适用goto语句</p></li><li><p>函数调用语句: 由一个函数调用和一个分号组成 如 printf();</p></li><li><p>表达式语句 如a=3;</p></li><li><p>空语句 ；</p></li><li><p>复合语句 也称语句块（代码块）形如：{ a=3;b=4;} </p><blockquote><p>注意：复合语句中最后的分号不能忽略不写</p></blockquote></li></ol><h3 id="3-3-2-最基本的语句-赋值语句"><a href="#3-3-2-最基本的语句-赋值语句" class="headerlink" title="3.3.2 最基本的语句-赋值语句"></a>3.3.2 最基本的语句-赋值语句</h3><ol><li><p>赋值运算符</p></li><li><p>复合的赋值运算符</p></li><li><p>赋值表达式</p></li><li><p>赋值过程中的类型转换</p><p>浮点类型-&gt;整形  小数部分舍弃</p><p>整形-&gt;浮点类型   小数部分补零</p></li></ol><h2 id="3-4-数据的输入输出"><a href="#3-4-数据的输入输出" class="headerlink" title="3.4 数据的输入输出"></a>3.4 数据的输入输出</h2><h3 id="3-4-2-有关数据输入输出的概念"><a href="#3-4-2-有关数据输入输出的概念" class="headerlink" title="3.4.2 有关数据输入输出的概念"></a>3.4.2 有关数据输入输出的概念</h3><ol><li><p>输入输出是针对计算机而言的</p></li><li><p>C语言本身不提供输入输出语句，输入输出操作由C标准函数库实现的。</p><p>C提供的标准函数以库的形式在C的编译系统中提供，不是C语言文本的组成部分。</p></li><li><p>在使用系统库函数是，要在文件的开头用预处理命令#include 把有关头文件放在本程序中</p><p>#include&lt;stdio.h&gt;  stdio.h是包含了标准的I/O库有关的变量定义和宏定义以及对函数的声明</p></li></ol><h3 id="3-4-3-使用printf函数输出数据"><a href="#3-4-3-使用printf函数输出数据" class="headerlink" title="3.4.3 使用printf函数输出数据"></a>3.4.3 使用printf函数输出数据</h3><p>printf函数的一般格式：</p><p>printf(格式控制，输出列表)；</p><p>printf(“%d”,c);</p><table><thead><tr><th>格式字符</th><th>说明</th></tr></thead><tbody><tr><td>%d</td><td>输出一个有符号的十进制</td></tr><tr><td>%c</td><td>输出一个字符</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr><tr><td>%f</td><td>输出浮点数        %7.2f代表数据宽度为7，其中包括2位小数           %-25.3f     代表输出数据向左对齐（当位数不足25时）%25.3f 输出数据左边以空格填充（当位数不足25位时）</td></tr><tr><td>%e</td><td>以指数形式输出实数 VisualC++小数位默认占6位</td></tr></tbody></table><p><img src="https://i.loli.net/2020/06/11/gOVsG69tHzSQhe2.png" alt="printf输出数据格式.png" loading="lazy"></p><h3 id="3-4-4-用scanf函数输入数据"><a href="#3-4-4-用scanf函数输入数据" class="headerlink" title="3.4.4 用scanf函数输入数据"></a>3.4.4 用scanf函数输入数据</h3><p>scanf函数的一般形式（语法）</p><p>scanf(格式控制，地址表列);</p><p>如scanf(“%d%f”,&amp;a,&amp;b);</p><p><strong>注意</strong></p><blockquote><ol><li><p>格式控制后面应当是变量地址，而不是变量名</p></li><li><p>格式控制字符串中除了格式声明以外还有其他字符，则在输入数据时在对应位置输入与这些字符相同的字符。</p><p>如：scanf(“a=%d,b=%c”,&amp;a,&amp;b); 则输入a=10,b=’c’</p></li><li><p>在使用“%c”格式声明时，空格字符和‘’转义字符 ‘’都作为有效字符。</p></li><li><p>在输入数值数据时，如输入空格、回车、Tab键，或遇非法字符，认为该数据结束。</p></li></ol></blockquote><h3 id="3-4-5-字符数据的输入输出"><a href="#3-4-5-字符数据的输入输出" class="headerlink" title="3.4.5 字符数据的输入输出"></a>3.4.5 字符数据的输入输出</h3><ol><li><p>用putchar()函数输出一个字符</p><p>语法：putchar(c); 输出变量c</p></li><li><p>用getchar()函数输入一个字符</p><p>语法：getchar()   注：此函数没有参数</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-acukgUau&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;



&lt;h2 id=&quot;3-1-顺序程序设计举例&quot;&gt;&lt;a href=&quot;#3-1-顺序程序设计举例&quot; class=&quot;headerlink&quot; title=&quot;3.1    顺序程序设计举例&quot;&gt;&lt;/a&gt;3.1    顺序程序设计举例&lt;/h2&gt;&lt;p&gt;略,自己看资料理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——程序的灵魂</title>
    <link href="https://www.nscblog.top/posts/4c65aa6d/"/>
    <id>https://www.nscblog.top/posts/4c65aa6d/</id>
    <published>2020-03-25T12:40:23.000Z</published>
    <updated>2020-08-23T06:14:59.678Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-SEKZezyB" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>程序包含两个方面的信息:</p><ol><li><p>对数据的描述:</p><p>就是数据结构：程序中要指定用到哪些数据以及这些数据的类型和数据的组织形式.</p><p>需要的数据    数据的类型    数据的存储的形式 如:key-value</p></li><li><p>对操作的描述:即要求计算机进行操作的步骤,也就是算法</p><p>数据是操作对象</p><p>操作的目的是对数据进行加工处理来得到想要的结果 </p></li></ol><p>程序设计人员应具备的知识:  算法、数据结构、程序设计方法、语言工具。</p><p>​            算法+数据结构=程序</p><p>算法是灵魂，语言是工具，数据结构是加工对象，编程需要采用合适的方法</p><a id="more"></a><h2 id="2-1-什么是算法"><a href="#2-1-什么是算法" class="headerlink" title="2.1    什么是算法"></a>2.1    什么是算法</h2><p>算法(广义):    解决一个问题采取的方法和步骤</p><p>计算机语言算法 :程序</p><h2 id="2-2-简单的算法举例"><a href="#2-2-简单的算法举例" class="headerlink" title="2.2    简单的算法举例"></a>2.2    简单的算法举例</h2><p>略</p><h2 id="2-3-算法的特性"><a href="#2-3-算法的特性" class="headerlink" title="2.3    算法的特性"></a>2.3    算法的特性</h2><p>有效算法的特点:</p><ol><li><p>有穷性:一个算法包含有限的操作步骤,而不能是无限的</p></li><li><p>确定性:算法每个步骤都是确定的,不会产生歧义</p></li><li><p>零个或多个输入(形式参数表):输入是指执行算法时需要从外界取得必要的信息.</p></li><li><p>有一个或多个输出:算法的目的是为了求解.</p></li><li><p>有效性：算法中每步能有效的执行</p></li></ol><h2 id="2-4-表示一个算法"><a href="#2-4-表示一个算法" class="headerlink" title="2.4    表示一个算法"></a>2.4    表示一个算法</h2><h3 id="2-4-1-用自然语言表示"><a href="#2-4-1-用自然语言表示" class="headerlink" title="2.4.1    用自然语言表示"></a>2.4.1    用自然语言表示</h3><p>用人们日常使用语言表示一个算法</p><h3 id="2-4-2-用流程图表示"><a href="#2-4-2-用流程图表示" class="headerlink" title="2.4.2    用流程图表示"></a>2.4.2    用流程图表示</h3><p>流程图用一些图框表示各种操作</p><h3 id="2-4-3-三种基本结构和改进的流程图"><a href="#2-4-3-三种基本结构和改进的流程图" class="headerlink" title="2.4.3    三种基本结构和改进的流程图"></a>2.4.3    三种基本结构和改进的流程图</h3><h4 id="传统流程图的弊端"><a href="#传统流程图的弊端" class="headerlink" title="传统流程图的弊端"></a>传统流程图的弊端</h4><p>没有严格规范,不易阅读和理解算法逻辑</p><p>算法可靠性弱,可维护性低</p><h4 id="三种基本结构"><a href="#三种基本结构" class="headerlink" title="三种基本结构"></a>三种基本结构</h4><blockquote><p>用三种基本结构作为一个良好算法的节本单元</p></blockquote><ol><li><p>顺序结构:</p><p>最简单的一种基本结构</p></li><li><p>选择结构:</p><p>选择结构又称选取结构或分支结构判定给定的条件是否成立,从而选择执行A或B</p></li><li><p>循环结构:</p><p>又称重复结构,反复执行某一部分的操作</p></li></ol><p>三种基本结构共同点:</p><p><u>1.只有一个入口</u></p><p><u>2.只有一个出口</u></p><p><u>3.结构内每一部分都有机会被执行到</u></p><p><u>4.结构内不存在死循环(体现了算法的有穷性,步骤是有限的,如:调用一个循环时,条件不会是一个无限循环的条件)</u></p><h3 id="2-4-4-用N-S流程图表示算法"><a href="#2-4-4-用N-S流程图表示算法" class="headerlink" title="2.4.4    用N-S流程图表示算法"></a>2.4.4    用N-S流程图表示算法</h3><blockquote><p>在基本结构上进行修改,去掉带箭头的流程线,算法全部写在一个矩形框中,框中包含其他从属关系.</p><p>简单来说,由一些基本的框组成一个大框.</p></blockquote><p>如</p><p><img src="https://i.loli.net/2020/06/11/ARlVudmQygJqTPz.gif" alt="n-s.gif" loading="lazy"></p><p><img src="https://i.loli.net/2020/06/11/gXATrhsuMD12tcG.png" alt="N-S流程图.png" loading="lazy"></p><h3 id="2-4-5-用伪代码表示算法"><a href="#2-4-5-用伪代码表示算法" class="headerlink" title="2.4.5    用伪代码表示算法"></a>2.4.5    用伪代码表示算法</h3><p>伪代码写算法并无固定的，严格的语法规则，只要把意思表达清楚，便于书写和阅读即可，书写的格式要写成清晰易读的形式。</p><h3 id="2-4-6-用计算机语言表示算法"><a href="#2-4-6-用计算机语言表示算法" class="headerlink" title="2.4.6    用计算机语言表示算法"></a>2.4.6    用计算机语言表示算法</h3><p>完成一项工作，包括设计算法和实现算法两个部分</p><p>如：菜谱是一个算法，厨师炒菜就是在实现这个算法</p><p>对于计算机来说，只能用计算机语言来实现算法，流程图和伪代码是无法识别的。</p><blockquote><p>注意：对于C语言来说，写出了C程序，仍然只是描述了算法，并未实现算法，只有运行程序才是实现了算法。</p></blockquote><h2 id="2-5-结构化程序设计方法"><a href="#2-5-结构化程序设计方法" class="headerlink" title="2.5    结构化程序设计方法"></a>2.5    结构化程序设计方法</h2><p>结构化程序设计的目的：程序设计风格和程序结构的规范化。</p><p>结构化程序设计方法的基本思路：</p><p>​    将复杂问题的求解过程分段进行，每个阶段处理的问题到控制在人们理解和处理的范围内。</p><p>主要采取的设计方法：</p><p>1&gt;自定向下</p><p>2&gt;逐步细化</p><p>3&gt;模块化设计</p><p>4&gt;结构化编码</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-SEKZezyB&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;

&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;程序包含两个方面的信息:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对数据的描述:&lt;/p&gt;
&lt;p&gt;就是数据结构：程序中要指定用到哪些数据以及这些数据的类型和数据的组织形式.&lt;/p&gt;
&lt;p&gt;需要的数据    数据的类型    数据的存储的形式 如:key-value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对操作的描述:即要求计算机进行操作的步骤,也就是算法&lt;/p&gt;
&lt;p&gt;数据是操作对象&lt;/p&gt;
&lt;p&gt;操作的目的是对数据进行加工处理来得到想要的结果 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;程序设计人员应具备的知识:  算法、数据结构、程序设计方法、语言工具。&lt;/p&gt;
&lt;p&gt;​            算法+数据结构=程序&lt;/p&gt;
&lt;p&gt;算法是灵魂，语言是工具，数据结构是加工对象，编程需要采用合适的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>程序设计和C语言</title>
    <link href="https://www.nscblog.top/posts/31f32bba/"/>
    <id>https://www.nscblog.top/posts/31f32bba/</id>
    <published>2020-03-20T12:47:52.000Z</published>
    <updated>2020-08-23T06:14:52.196Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-RcAjfzWO" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20744788" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h2 id="1-1-什么是计算机程序"><a href="#1-1-什么是计算机程序" class="headerlink" title="1.1    什么是计算机程序"></a>1.1    什么是计算机程序</h2><blockquote><p>程序: 一组计算机能识别和执行的指令</p></blockquote><p><strong>每条指令使计算机执行特定的操作,一个特定的指令序列(指令集合),用来完成一定的功能.</strong></p><p><strong><u>计算机的本质是程序的机器</u></strong></p><a id="more"></a><h2 id="1-2-什么是计算机语言"><a href="#1-2-什么是计算机语言" class="headerlink" title="1.2    什么是计算机语言"></a>1.2    什么是计算机语言</h2><p>个人简单理解:人与计算机交互的工具</p><blockquote><p>计算机与人都能识别的语言这就是计算机语言</p></blockquote><p>计算机语言的发展阶段:</p><p><strong>机器语言</strong></p><p><strong><u><em>计算机是基于二进制工作的</em></u></strong></p><blockquote><p>机器指令:计算机能够识别和接受的二进制代码.</p><p>机器语言:机器指令的集合.</p></blockquote><p>缺点:不容易使用,难以修改程序代码</p><p><strong>符号语言(汇编语言)</strong></p><blockquote><p>符号语言:英文数字表示一个指令</p></blockquote><p>例如:ADD表示 <strong>加</strong></p><p>由于计算机不能直接识别 执行符号语言,所以要通过汇编程序的软件将符号语言的指令转换为机器指令. 转换的过程称为”代真”或”汇编”,因而符号语言又叫汇编语言或符号汇编</p><p>优点:</p><p>相对于机器语言方便使用</p><p>缺点:</p><p>程序可移植性差,机器依赖性强,如:机器A的上的程序无法在机器B上使用 </p><p>机器语言和汇编语言是完全<strong>依赖于具体机器特性</strong>的,是面向机器的语言,相对于其他语言来说更”贴近”计算机,背称为计算机<strong>低级语言.</strong></p><p><strong>高级语言</strong></p><ul><li><p>不依赖于具体机器，它与具体计算机距离较远。</p></li><li><p>世界第一个计算机高级语言  FORTRAN语言(20世纪50年代)</p></li><li><p>高级语言需要通过<strong>编译器</strong>程序软件转换为机器指令的程序</p></li><li><p>高级语言的一个语句一般对应多条机器指令</p></li></ul><p>优点:</p><ol><li><p>高级语言数据结构丰富</p></li><li><p>不依赖于具体机器,它与具体计算机距离较远.(可移植性强)</p></li><li><p>简单易学,容易推广</p></li><li><p>高级语言的出现是计算机发展史上”惊人的成就”</p></li></ol><p><strong>高级语言的发展阶段</strong></p><p>非结构化语言</p><ul><li><p>符合语法要求,没有严格规范要求</p></li><li><p>程序难以维护和难以阅读</p></li><li><p>早期的BASIC FORTRAN和ALGOL都属于非结构化语言</p></li></ul><p>结构化语言</p><ul><li><p>为了解决非结构化语言的缺点(程序难以维护和阅读),提出结构化程序设计方法</p></li><li><p>程序由良好的基本结构(顺序结构 分支结构 循环结构)构成 程序中的流程不得随意跳转</p></li><li><p>程序结构清晰,易于编写 阅读和维护</p></li><li><p>QBASIC FORTRAN77和C语言都是结构化语言 </p></li></ul><p><u>语言特点:支持结构化程序设计方法</u></p><p>缺点:</p><p>​    在编写程序时需要制定具体每个过程的细节 —-&gt; 规模小的程序 还可以 规模较大的程序显得力不从心(面向过程编程)</p><p>面向对象语言：对象由数据以及对数据进行的操作构成的，用于处理规模较大的程序。</p><h2 id="1-3-C语言的发展及其特点"><a href="#1-3-C语言的发展及其特点" class="headerlink" title="1.3    C语言的发展及其特点"></a>1.3    C语言的发展及其特点</h2><p>C语言是国际广泛流行的计算机高级语言。</p><p>c语言的祖先是BCPL语言 c语言的设计最初是为了Unix提供一种工作语言 </p><p>C语言的特点:</p><p>1.语言简洁 紧凑,使用方便灵活</p><p>2.运算符丰富</p><p>3.数据类型丰富</p><p>4.具有结构化的控制语句</p><p>5.语法灵活,程序设计自由度大</p><p><strong>6.C语言允许直接访问物理地址</strong></p><p><strong>7.C语言程序可移植性好</strong></p><p><strong>8.代码质量高,程序执行效率高</strong></p><p><strong>C语言原来是专门为系统软件而设计的</strong></p><h2 id="1-4-最简单的C语言程序"><a href="#1-4-最简单的C语言程序" class="headerlink" title="1.4    最简单的C语言程序"></a>1.4    最简单的C语言程序</h2><h3 id="1-4-1-最简单的C语言程举例"><a href="#1-4-1-最简单的C语言程举例" class="headerlink" title="1.4.1    最简单的C语言程举例"></a>1.4.1    最简单的C语言程举例</h3><pre><code class="c">#include&lt;stdio.h&gt;void main(){    int max(int x, int y);//调用max函数的声明     int a,b,c;//声明变量a b c    /*        &amp;: 地址符         &amp;a:a变量的地址     */    scanf(&quot;%d,%d&quot;,&amp;a,&amp;b);//scanf是一个输入函数 输入a和b的值    c = max(a,b);//调用max函数 将得到的值复制给C    printf(&quot;max=%d\n&quot;,c);//输出C的值 }int max(int x, int y){    if(x&gt;y){        return(x);    }else{        return(y);    }}</code></pre><h3 id="1-4-2-c语言程序的结构"><a href="#1-4-2-c语言程序的结构" class="headerlink" title="1.4.2 c语言程序的结构"></a>1.4.2 c语言程序的结构</h3><p>c语言程序的结构:</p><p><strong>1.一个程序由一个或多个源程序文件组成。</strong></p><pre><code class="markdown">- 规模较小的程序，往往只包括一个源程序文件(一个源文件中只有一个main函数)。一个源程序文件中可以包括3个部分:    1. 预处理指令 如:#include&lt;stdio.h&gt; #define        C编译系统在对源程序进行&quot;翻译&quot;(转换为二进制)以前,        先由一个&quot;预处理器&quot;对指令进行预处理:将头文件的内容读取,放在#include后面        编译程序对源程序进行编译得到目标程序（机器指令）    2. 全局声明(在函数之外进行的数据声明)        相当于Java中成员属性        作用范围:整个源程序文件    3. 函数定义        每个函数用来实现一定的功能。调用这些函数时，会完成函数定义中指定的功能。</code></pre><p><strong>2.函数是C程序的主要组成部分</strong></p><pre><code class="markdown">函数是C程序的基本单位，在设计良好的程序中，每个函数都用来实现一个或几个特地当的功能。编写C程序的主要工作就是编写一个个函数。C程序有且仅有一个main函数，有一个或多个函数组成当程序规模较大时，为了方便编译 调试和管理，一个程序可以包括若干个源程序文件 一个源程序文件就是一个程序模块编译时，对个源文件程序进行编译得到相应的目标程序，将目标程序连接成为一个统一的二进制可执行程序程序中调用的函数可以是自定函数，可以是库函数</code></pre><p><strong>3.一个函数包括两个部分</strong></p><p>int max (int x){}</p><p>​    <strong>函数首部</strong></p><blockquote><p>int                 max             (int                             x)</p><p>函数类型       函数名        函数参数类型            函数参数名</p></blockquote><p>​    <strong>函数体</strong>:{}(离函数首部最近的)</p><p>​        声明部分:</p><p>​            在调用函数中定义变量</p><p>​            对被调用函数进行声明</p><p>​        执行部分:</p><p>​            {}中的语句,指定在函数中进行的操作 也可以什么都不做即一个空函数</p><p><strong>4.程序总是从main函数开始执行的</strong></p><p><strong>5.程序中对计算机的操作是由函数中的C语句完成的。</strong></p><p><strong>6.在每个数据声明语句的最后必须有一个分号</strong></p><p><strong>7.C语言本身不提供输入输出语句</strong></p><p>​    输入输出的操作是由库函数来完成的</p><p><strong>8.程序应当包含注释</strong></p><p>​    增加必要的注释，提高程序的可读性。</p><h2 id="1-5-运行C程序的步骤与方法"><a href="#1-5-运行C程序的步骤与方法" class="headerlink" title="1.5 运行C程序的步骤与方法"></a>1.5 运行C程序的步骤与方法</h2><p><strong>1.上机输入和编辑源程序</strong></p><p><strong>2.对源程序进行编译</strong></p><pre><code>1.先对程序中的预处理指令进行编译预处理2.在对完整的源程序进行编译编译的作用：首先是检查源程序中是否有语法错误没有语法错误之后，再编译时，自动包括了预编译和正式编译连个阶段，用户不用发出两次指令</code></pre><p><strong>3.进行连接处理</strong></p><p>编译后得到的目标模块连接装配起来,再与函数库连接成一个整体,生成一个课供计算机执行的目标程序,称为 <strong>可执行程序</strong></p><p>连接工作由”连接编辑程序”的软件来实现</p><p><strong>4.运行可执行程序</strong></p><p><img src="https://i.loli.net/2020/06/11/p49MFkUInPSDrgB.png" alt="运行C程序的流程图.png" loading="lazy"></p><h2 id="1-6-程序设计的任务"><a href="#1-6-程序设计的任务" class="headerlink" title="1.6 程序设计的任务"></a>1.6 程序设计的任务</h2><blockquote><p>程序设计是指从确定任务到得到结果,写出文档的全过程</p></blockquote><p>一般经历以下几个工作阶段:</p><p><strong>1.问题分析</strong></p><p>​    研究给定条件 分析最终目标,找出解题规律,选择合适的解题方法</p><p><strong>2.设计算法</strong></p><p>​    设计出解题的方法和具体步骤</p><p><strong>3.编写程序</strong></p><p>​    根据得出的算法,用高级语言编写出源程序</p><p><strong>4.对源程序进行编辑 编译和连接,得到执行程序</strong></p><p><strong>5.运行程序,分析结果</strong></p><p>​    对程序进行调试,发现和排除程序中故障的工程</p><p>​    测试:设计多组测试数据,检查不同数据的运行情况,尽量找出程序中存在的漏洞,并修改程序,使程序能够适应各种情况.</p><p><strong>6.编写程序文档</strong></p><p>提供程序说明书内容应该包括</p><p>程序名称    程序功能    运行环境    程序安装和启动,需要输入的数据,以及使用注意事项</p><blockquote><p>软件是计算机程序和程序文档的总称</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-RcAjfzWO&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot;
         data-id=&quot;20744788&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;true&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#C20C0C&quot;
    &gt;&lt;/div&gt;



&lt;h2 id=&quot;1-1-什么是计算机程序&quot;&gt;&lt;a href=&quot;#1-1-什么是计算机程序&quot; class=&quot;headerlink&quot; title=&quot;1.1    什么是计算机程序&quot;&gt;&lt;/a&gt;1.1    什么是计算机程序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;程序: 一组计算机能识别和执行的指令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;每条指令使计算机执行特定的操作,一个特定的指令序列(指令集合),用来完成一定的功能.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;计算机的本质是程序的机器&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="专升本笔记" scheme="https://www.nscblog.top/categories/%E4%B8%93%E5%8D%87%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="https://www.nscblog.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C语言" scheme="https://www.nscblog.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
